// Generated by Haxe 4.3.2
(function ($global) { "use strict";
var $estr = function() { return js_Boot.__string_rec(this,''); },$hxEnums = $hxEnums || {},$_;
class EReg {
	constructor(r,opt) {
		this.r = new RegExp(r,opt.split("u").join(""));
	}
	match(s) {
		if(this.r.global) {
			this.r.lastIndex = 0;
		}
		this.r.m = this.r.exec(s);
		this.r.s = s;
		return this.r.m != null;
	}
	split(s) {
		return s.replace(this.r,"#__delim__#").split("#__delim__#");
	}
}
EReg.__name__ = "EReg";
Object.assign(EReg.prototype, {
	__class__: EReg
});
class HxOverrides {
	static cca(s,index) {
		let x = s.charCodeAt(index);
		if(x != x) {
			return undefined;
		}
		return x;
	}
	static substr(s,pos,len) {
		if(len == null) {
			len = s.length;
		} else if(len < 0) {
			if(pos == 0) {
				len = s.length + len;
			} else {
				return "";
			}
		}
		return s.substr(pos,len);
	}
	static remove(a,obj) {
		let i = a.indexOf(obj);
		if(i == -1) {
			return false;
		}
		a.splice(i,1);
		return true;
	}
	static now() {
		return Date.now();
	}
}
HxOverrides.__name__ = "HxOverrides";
class IntIterator {
	constructor(min,max) {
		this.min = min;
		this.max = max;
	}
	hasNext() {
		return this.min < this.max;
	}
	next() {
		return this.min++;
	}
}
IntIterator.__name__ = "IntIterator";
Object.assign(IntIterator.prototype, {
	__class__: IntIterator
});
class Lambda {
	static array(it) {
		let a = [];
		let i = $getIterator(it);
		while(i.hasNext()) a.push(i.next());
		return a;
	}
	static list(it) {
		let l = new haxe_ds_List();
		let i = $getIterator(it);
		while(i.hasNext()) l.add(i.next());
		return l;
	}
	static map(it,f) {
		let l = new haxe_ds_List();
		let x = $getIterator(it);
		while(x.hasNext()) l.add(f(x.next()));
		return l;
	}
	static mapi(it,f) {
		let l = new haxe_ds_List();
		let i = 0;
		let x = $getIterator(it);
		while(x.hasNext()) l.add(f(i++,x.next()));
		return l;
	}
	static flatten(it) {
		let l = new haxe_ds_List();
		let e = $getIterator(it);
		while(e.hasNext()) {
			let x = $getIterator(e.next());
			while(x.hasNext()) l.add(x.next());
		}
		return l;
	}
	static flatMap(it,f) {
		return Lambda.flatten(Lambda.map(it,f));
	}
	static has(it,elt) {
		let x = $getIterator(it);
		while(x.hasNext()) if(x.next() == elt) {
			return true;
		}
		return false;
	}
	static exists(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) if(f(x.next())) {
			return true;
		}
		return false;
	}
	static foreach(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) if(!f(x.next())) {
			return false;
		}
		return true;
	}
	static iter(it,f) {
		let x = $getIterator(it);
		while(x.hasNext()) f(x.next());
	}
	static filter(it,f) {
		let l = new haxe_ds_List();
		let x = $getIterator(it);
		while(x.hasNext()) {
			let x1 = x.next();
			if(f(x1)) {
				l.add(x1);
			}
		}
		return l;
	}
	static fold(it,f,first) {
		let x = $getIterator(it);
		while(x.hasNext()) first = f(x.next(),first);
		return first;
	}
	static count(it,pred) {
		let n = 0;
		if(pred == null) {
			let _ = $getIterator(it);
			while(_.hasNext()) {
				_.next();
				++n;
			}
		} else {
			let x = $getIterator(it);
			while(x.hasNext()) if(pred(x.next())) {
				++n;
			}
		}
		return n;
	}
	static empty(it) {
		return !$getIterator(it).hasNext();
	}
	static indexOf(it,v) {
		let i = 0;
		let v2 = $getIterator(it);
		while(v2.hasNext()) {
			if(v == v2.next()) {
				return i;
			}
			++i;
		}
		return -1;
	}
	static find(it,f) {
		let v = $getIterator(it);
		while(v.hasNext()) {
			let v1 = v.next();
			if(f(v1)) {
				return v1;
			}
		}
		return null;
	}
	static concat(a,b) {
		let l = new haxe_ds_List();
		let x = $getIterator(a);
		while(x.hasNext()) l.add(x.next());
		let x1 = $getIterator(b);
		while(x1.hasNext()) l.add(x1.next());
		return l;
	}
}
Lambda.__name__ = "Lambda";
Math.__name__ = "Math";
class Reflect {
	static field(o,field) {
		try {
			return o[field];
		} catch( _g ) {
			return null;
		}
	}
	static fields(o) {
		let a = [];
		if(o != null) {
			let hasOwnProperty = Object.prototype.hasOwnProperty;
			for( var f in o ) {
			if(f != "__id__" && f != "hx__closures__" && hasOwnProperty.call(o,f)) {
				a.push(f);
			}
			}
		}
		return a;
	}
	static isFunction(f) {
		if(typeof(f) == "function") {
			return !(f.__name__ || f.__ename__);
		} else {
			return false;
		}
	}
	static deleteField(o,field) {
		if(!Object.prototype.hasOwnProperty.call(o,field)) {
			return false;
		}
		delete(o[field]);
		return true;
	}
	static copy(o) {
		if(o == null) {
			return null;
		}
		let o2 = { };
		let _g = 0;
		let _g1 = Reflect.fields(o);
		while(_g < _g1.length) {
			let f = _g1[_g];
			++_g;
			o2[f] = Reflect.field(o,f);
		}
		return o2;
	}
}
Reflect.__name__ = "Reflect";
class Std {
	static string(s) {
		return js_Boot.__string_rec(s,"");
	}
	static parseInt(x) {
		let v = parseInt(x);
		if(isNaN(v)) {
			return null;
		}
		return v;
	}
}
Std.__name__ = "Std";
class StringTools {
	static isSpace(s,pos) {
		let c = HxOverrides.cca(s,pos);
		if(!(c > 8 && c < 14)) {
			return c == 32;
		} else {
			return true;
		}
	}
	static ltrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,r)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,r,l - r);
		} else {
			return s;
		}
	}
	static rtrim(s) {
		let l = s.length;
		let r = 0;
		while(r < l && StringTools.isSpace(s,l - r - 1)) ++r;
		if(r > 0) {
			return HxOverrides.substr(s,0,l - r);
		} else {
			return s;
		}
	}
	static trim(s) {
		return StringTools.ltrim(StringTools.rtrim(s));
	}
	static hex(n,digits) {
		let s = "";
		do {
			s = "0123456789ABCDEF".charAt(n & 15) + s;
			n >>>= 4;
		} while(n > 0);
		if(digits != null) {
			while(s.length < digits) s = "0" + s;
		}
		return s;
	}
}
StringTools.__name__ = "StringTools";
var ValueType = $hxEnums["ValueType"] = { __ename__:true,__constructs__:null
	,TNull: {_hx_name:"TNull",_hx_index:0,__enum__:"ValueType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:1,__enum__:"ValueType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:2,__enum__:"ValueType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:3,__enum__:"ValueType",toString:$estr}
	,TObject: {_hx_name:"TObject",_hx_index:4,__enum__:"ValueType",toString:$estr}
	,TFunction: {_hx_name:"TFunction",_hx_index:5,__enum__:"ValueType",toString:$estr}
	,TClass: ($_=function(c) { return {_hx_index:6,c:c,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TClass",$_.__params__ = ["c"],$_)
	,TEnum: ($_=function(e) { return {_hx_index:7,e:e,__enum__:"ValueType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["e"],$_)
	,TUnknown: {_hx_name:"TUnknown",_hx_index:8,__enum__:"ValueType",toString:$estr}
};
ValueType.__constructs__ = [ValueType.TNull,ValueType.TInt,ValueType.TFloat,ValueType.TBool,ValueType.TObject,ValueType.TFunction,ValueType.TClass,ValueType.TEnum,ValueType.TUnknown];
class Type {
	static createEnum(e,constr,params) {
		let f = Reflect.field(e,constr);
		if(f == null) {
			throw haxe_Exception.thrown("No such constructor " + constr);
		}
		if(Reflect.isFunction(f)) {
			if(params == null) {
				throw haxe_Exception.thrown("Constructor " + constr + " need parameters");
			}
			return f.apply(e,params);
		}
		if(params != null && params.length != 0) {
			throw haxe_Exception.thrown("Constructor " + constr + " does not need parameters");
		}
		return f;
	}
	static createEnumIndex(e,index,params) {
		let c;
		let _g = e.__constructs__[index];
		if(_g == null) {
			c = null;
		} else {
			let ctor = _g;
			c = ctor._hx_name;
		}
		if(c == null) {
			throw haxe_Exception.thrown(index + " is not a valid enum constructor index");
		}
		return Type.createEnum(e,c,params);
	}
	static typeof(v) {
		switch(typeof(v)) {
		case "boolean":
			return ValueType.TBool;
		case "function":
			if(v.__name__ || v.__ename__) {
				return ValueType.TObject;
			}
			return ValueType.TFunction;
		case "number":
			if(Math.ceil(v) == v % 2147483648.0) {
				return ValueType.TInt;
			}
			return ValueType.TFloat;
		case "object":
			if(v == null) {
				return ValueType.TNull;
			}
			let e = v.__enum__;
			if(e != null) {
				return ValueType.TEnum($hxEnums[e]);
			}
			let c = js_Boot.getClass(v);
			if(c != null) {
				return ValueType.TClass(c);
			}
			return ValueType.TObject;
		case "string":
			return ValueType.TClass(String);
		case "undefined":
			return ValueType.TNull;
		default:
			return ValueType.TUnknown;
		}
	}
	static enumEq(a,b) {
		if(a == b) {
			return true;
		}
		try {
			let e = a.__enum__;
			if(e == null || e != b.__enum__) {
				return false;
			}
			if(a._hx_index != b._hx_index) {
				return false;
			}
			let enm = $hxEnums[e];
			let params = enm.__constructs__[a._hx_index].__params__;
			let _g = 0;
			while(_g < params.length) {
				let f = params[_g];
				++_g;
				if(!Type.enumEq(a[f],b[f])) {
					return false;
				}
			}
		} catch( _g ) {
			return false;
		}
		return true;
	}
	static enumParameters(e) {
		let enm = $hxEnums[e.__enum__];
		let params = enm.__constructs__[e._hx_index].__params__;
		if(params != null) {
			let _g = [];
			let _g1 = 0;
			while(_g1 < params.length) {
				let p = params[_g1];
				++_g1;
				_g.push(e[p]);
			}
			return _g;
		} else {
			return [];
		}
	}
}
Type.__name__ = "Type";
var cdb_ColumnType = $hxEnums["cdb.ColumnType"] = { __ename__:true,__constructs__:null
	,TId: {_hx_name:"TId",_hx_index:0,__enum__:"cdb.ColumnType",toString:$estr}
	,TString: {_hx_name:"TString",_hx_index:1,__enum__:"cdb.ColumnType",toString:$estr}
	,TBool: {_hx_name:"TBool",_hx_index:2,__enum__:"cdb.ColumnType",toString:$estr}
	,TInt: {_hx_name:"TInt",_hx_index:3,__enum__:"cdb.ColumnType",toString:$estr}
	,TFloat: {_hx_name:"TFloat",_hx_index:4,__enum__:"cdb.ColumnType",toString:$estr}
	,TEnum: ($_=function(values) { return {_hx_index:5,values:values,__enum__:"cdb.ColumnType",toString:$estr}; },$_._hx_name="TEnum",$_.__params__ = ["values"],$_)
	,TRef: ($_=function(sheet) { return {_hx_index:6,sheet:sheet,__enum__:"cdb.ColumnType",toString:$estr}; },$_._hx_name="TRef",$_.__params__ = ["sheet"],$_)
	,TImage: {_hx_name:"TImage",_hx_index:7,__enum__:"cdb.ColumnType",toString:$estr}
	,TList: {_hx_name:"TList",_hx_index:8,__enum__:"cdb.ColumnType",toString:$estr}
	,TCustom: ($_=function(name) { return {_hx_index:9,name:name,__enum__:"cdb.ColumnType",toString:$estr}; },$_._hx_name="TCustom",$_.__params__ = ["name"],$_)
	,TFlags: ($_=function(values) { return {_hx_index:10,values:values,__enum__:"cdb.ColumnType",toString:$estr}; },$_._hx_name="TFlags",$_.__params__ = ["values"],$_)
	,TColor: {_hx_name:"TColor",_hx_index:11,__enum__:"cdb.ColumnType",toString:$estr}
	,TLayer: ($_=function(type) { return {_hx_index:12,type:type,__enum__:"cdb.ColumnType",toString:$estr}; },$_._hx_name="TLayer",$_.__params__ = ["type"],$_)
	,TFile: {_hx_name:"TFile",_hx_index:13,__enum__:"cdb.ColumnType",toString:$estr}
	,TTilePos: {_hx_name:"TTilePos",_hx_index:14,__enum__:"cdb.ColumnType",toString:$estr}
	,TTileLayer: {_hx_name:"TTileLayer",_hx_index:15,__enum__:"cdb.ColumnType",toString:$estr}
	,TDynamic: {_hx_name:"TDynamic",_hx_index:16,__enum__:"cdb.ColumnType",toString:$estr}
	,TProperties: {_hx_name:"TProperties",_hx_index:17,__enum__:"cdb.ColumnType",toString:$estr}
};
cdb_ColumnType.__constructs__ = [cdb_ColumnType.TId,cdb_ColumnType.TString,cdb_ColumnType.TBool,cdb_ColumnType.TInt,cdb_ColumnType.TFloat,cdb_ColumnType.TEnum,cdb_ColumnType.TRef,cdb_ColumnType.TImage,cdb_ColumnType.TList,cdb_ColumnType.TCustom,cdb_ColumnType.TFlags,cdb_ColumnType.TColor,cdb_ColumnType.TLayer,cdb_ColumnType.TFile,cdb_ColumnType.TTilePos,cdb_ColumnType.TTileLayer,cdb_ColumnType.TDynamic,cdb_ColumnType.TProperties];
class cdb_TileMode {
	static _new(s) {
		return s;
	}
	static ofString(s) {
		return cdb_TileMode._new(s);
	}
	static toString(this1) {
		return this1;
	}
}
class cdb_Database {
	constructor() {
		this.r_ident = new EReg("^[A-Za-z_][A-Za-z0-9_]*$","");
		this.data = { sheets : [], customTypes : [], compress : false};
		this.sheets = [];
		this.sync();
	}
	get_compress() {
		return this.data.compress;
	}
	set_compress(b) {
		if(this.data.compress == b) {
			return b;
		}
		this.data.compress = b;
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = s.sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				switch(c.type._hx_index) {
				case 12:
					let _g = 0;
					let _g1 = s.getLines();
					while(_g < _g1.length) {
						let obj = _g1[_g];
						++_g;
						let ldat = Reflect.field(obj,c.name);
						if(ldat == null || ldat == "") {
							continue;
						}
						let _g2 = [];
						let _g3 = 0;
						while(_g3 < 256) _g2.push(_g3++);
						ldat = cdb_Layer.encode(cdb_Layer.decode(ldat,_g2),this.data.compress);
						obj[c.name] = ldat;
					}
					break;
				case 15:
					let _g4 = 0;
					let _g5 = s.getLines();
					while(_g4 < _g5.length) {
						let ldat = Reflect.field(_g5[_g4++],c.name);
						if(ldat == null || ldat == "") {
							continue;
						}
						ldat["data"] = cdb_TileLayerData.encode(cdb_TileLayerData.decode(ldat.data),this.data.compress);
					}
					break;
				default:
				}
			}
		}
		return b;
	}
	getCustomType(name) {
		return this.tmap.h[name];
	}
	getSheet(name) {
		return this.smap.h[name];
	}
	createSheet(name,sheetType,index) {
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) if(_g1[_g++].sheet.name == name) {
			return null;
		}
		return this.addSheet({ sheetType : sheetType, name : name, columns : [], lines : [], separators : [], props : { }},index);
	}
	moveSheet(s,delta) {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.sheets;
		while(_g1 < _g2.length) {
			let s = _g2[_g1];
			++_g1;
			if(!s.sheet.props.hide) {
				_g.push(s);
			}
		}
		let index = _g.indexOf(s);
		let other = _g[index + delta];
		if(index < 0 || other == null) {
			return false;
		}
		HxOverrides.remove(this.sheets,s);
		index = this.sheets.indexOf(other);
		if(delta > 0) {
			++index;
		}
		this.sheets.splice(index,0,s);
		let moved = [s];
		let delta1 = 0;
		let _g3 = 0;
		let _g4 = this.sheets.slice();
		while(_g3 < _g4.length) {
			let ssub = _g4[_g3];
			++_g3;
			let parent = ssub.getParent();
			if(parent != null && moved.indexOf(parent.s) >= 0) {
				HxOverrides.remove(this.sheets,ssub);
				this.sheets.splice(this.sheets.indexOf(s) + ++delta1,0,ssub);
				moved.push(ssub);
			}
		}
		this.updateSheets();
		return true;
	}
	addSheet(s,index) {
		let sobj = new cdb_Sheet(this,s);
		if(index != null) {
			this.data.sheets.splice(index,0,s);
		} else {
			this.data.sheets.push(s);
		}
		sobj.sync();
		if(index != null) {
			this.sheets.splice(index,0,sobj);
		} else {
			this.sheets.push(sobj);
		}
		return sobj;
	}
	createSubSheet(parent,c) {
		let s = { sheetType : cdb_SheetTypes.DATA_TABLE, name : parent.sheet.name + "@" + c.name, props : { hide : true}, separators : [], lines : [], columns : []};
		if(c.type == cdb_ColumnType.TProperties) {
			s.props.isProps = true;
		}
		let index = this.data.sheets.indexOf(Lambda.find(this.data.sheets,function(s) {
			return s.name == parent.sheet.name;
		}));
		let _g = 0;
		let _g1 = parent.sheet.columns;
		while(_g < _g1.length) {
			let c2 = _g1[_g];
			++_g;
			if(c == c2) {
				break;
			}
			let tmp;
			switch(c2.type._hx_index) {
			case 8:case 17:
				tmp = true;
				break;
			default:
				tmp = false;
			}
			if(tmp) {
				let sub = parent.base.getSheet(parent.sheet.name + "@" + c2.name);
				index = this.data.sheets.indexOf(sub.sheet);
			}
		}
		return this.addSheet(s,index < 0 ? null : index + 1);
	}
	sync() {
		this.smap = new haxe_ds_StringMap();
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) _g1[_g++].sync();
		this.tmap = new haxe_ds_StringMap();
		let _g2 = 0;
		let _g3 = this.data.customTypes;
		while(_g2 < _g3.length) {
			let t = _g3[_g2];
			++_g2;
			this.tmap.h[t.name] = t;
		}
	}
	getCustomTypes() {
		return this.data.customTypes;
	}
	load(content) {
		this.loadData(cdb_Parser.parse(content,true));
	}
	loadData(data) {
		this.data = data;
		if(this.sheets != null) {
			let _g = 0;
			let _g1 = this.sheets;
			while(_g < _g1.length) {
				let s = _g1[_g];
				++_g;
				s.base = null;
				s.index = null;
				s.sheet = null;
			}
		}
		let _g = [];
		let _g1 = 0;
		let _g2 = data.sheets;
		while(_g1 < _g2.length) _g.push(new cdb_Sheet(this,_g2[_g1++]));
		this.sheets = _g;
		this.sync();
	}
	cleanup() {
		this.cleanLayers();
	}
	cleanLayers() {
		let count = 0;
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			if(s.sheet.props.level == null) {
				continue;
			}
			let ts = s.sheet.props.level.tileSets;
			let usedLayers_h = Object.create(null);
			let _g2 = 0;
			let _g3 = s.sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				if(c.type._hx_index == 8) {
					let sub = s.base.getSheet(s.sheet.name + "@" + c.name);
					if(!sub.hasColumn("data",[cdb_ColumnType.TTileLayer])) {
						continue;
					}
					let _g = 0;
					let _g1 = sub.getLines();
					while(_g < _g1.length) {
						let v = _g1[_g++].data;
						if(v == null || v.file == null) {
							continue;
						}
						usedLayers_h[v.file] = true;
					}
				}
			}
			let _g4 = 0;
			let _g5 = Reflect.fields(ts);
			while(_g4 < _g5.length) {
				let f = _g5[_g4];
				++_g4;
				if(!usedLayers_h[f]) {
					Reflect.deleteField(ts,f);
					++count;
				}
			}
		}
		return count;
	}
	save() {
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			if(s.sheet.props.hasGroup) {
				let lines = s.getLines();
				let _g = 0;
				while(_g < lines.length) {
					let l = lines[_g];
					++_g;
					if(l.group != null) {
						Reflect.deleteField(l,"group");
					}
				}
			}
			let _g2 = 0;
			let _g3 = Reflect.fields(s.sheet.props);
			while(_g2 < _g3.length) {
				let p = _g3[_g2];
				++_g2;
				let v = Reflect.field(s.sheet.props,p);
				if(v == null || v == false) {
					Reflect.deleteField(s.sheet.props,p);
				}
			}
		}
		return cdb_Parser.save(this.data);
	}
	getDefault(c,ignoreOpt,sheet) {
		if(ignoreOpt == null) {
			ignoreOpt = false;
		}
		if(c.opt && !ignoreOpt) {
			return null;
		}
		let _g = c.type;
		switch(_g._hx_index) {
		case 2:
			if(c.opt) {
				return true;
			} else {
				return false;
			}
			break;
		case 5:
			return 0;
		case 6:
			let s = this.getSheet(_g.sheet);
			let l = s.sheet.lines[0];
			let id = "";
			if(l != null) {
				let _g = 0;
				let _g1 = s.sheet.columns;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(c.type == cdb_ColumnType.TId) {
						id = Reflect.field(l,c.name);
						break;
					}
				}
			}
			return id;
		case 8:
			return [];
		case 9:
			return null;
		case 10:
			return 0;
		case 3:case 4:case 11:
			return 0;
		case 12:
			return "";
		case 0:case 1:case 7:case 13:
			return "";
		case 14:case 15:case 16:
			return null;
		case 17:
			let obj = { };
			if(sheet != null) {
				let s = sheet.base.getSheet(sheet.sheet.name + "@" + c.name);
				let _g = 0;
				let _g1 = s.sheet.columns;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(!c.opt) {
						let def = this.getDefault(c,null,s);
						if(def != null) {
							obj[c.name] = def;
						}
					}
				}
			}
			return obj;
		}
	}
	typeStr(t) {
		switch(t._hx_index) {
		case 6:
			return t.sheet;
		case 9:
			return t.name;
		default:
			return HxOverrides.substr(Std.string(t),1,null);
		}
	}
	updateColumn(sheet,old,c) {
		if(old.name != c.name) {
			let _g = 0;
			let _g1 = sheet.sheet.columns;
			while(_g < _g1.length) if(_g1[_g++].name == c.name) {
				return "Column name already used";
			}
			if(c.name == "index" && sheet.sheet.props.hasIndex) {
				return "Sheet already has an index";
			}
			if(c.name == "group" && sheet.sheet.props.hasGroup) {
				return "Sheet already has a group";
			}
			let _g2 = 0;
			let _g3 = sheet.getLines();
			while(_g2 < _g3.length) {
				let o = _g3[_g2];
				++_g2;
				let v = Reflect.field(o,old.name);
				Reflect.deleteField(o,old.name);
				if(v != null) {
					o[c.name] = v;
				}
			}
			let renames = [];
			let renameRec = null;
			renameRec = function(sheet,col,newName) {
				let s = sheet.base.getSheet(sheet.sheet.name + "@" + col.name);
				renames.push(function() {
					s.rename(sheet.sheet.name + "@" + newName);
					s.sync();
				});
				let _g = 0;
				let _g1 = s.sheet.columns;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					if(c.type == cdb_ColumnType.TList || c.type == cdb_ColumnType.TProperties) {
						renameRec(s,c,c.name);
					}
				}
			};
			if(old.type == cdb_ColumnType.TList || old.type == cdb_ColumnType.TProperties) {
				renameRec(sheet,old,c.name);
				let _g = 0;
				while(_g < renames.length) renames[_g++]();
			}
			old.name = c.name;
		}
		if(!Type.enumEq(old.type,c.type)) {
			let conv = this.getConvFunction(old.type,c.type);
			if(conv == null) {
				return "Cannot convert " + this.typeStr(old.type) + " to " + this.typeStr(c.type);
			}
			let conv1 = conv.f;
			if(conv1 != null) {
				let _g = 0;
				let _g1 = sheet.getLines();
				while(_g < _g1.length) {
					let o = _g1[_g];
					++_g;
					let v = Reflect.field(o,c.name);
					if(v != null) {
						v = conv1(v);
						if(v != null) {
							o[c.name] = v;
						} else {
							Reflect.deleteField(o,c.name);
						}
					}
				}
			}
			let _g = c.type;
			switch(old.type._hx_index) {
			case 8:
				if(_g._hx_index == 17) {
					sheet.base.getSheet(sheet.sheet.name + "@" + old.name).sheet.props.isProps = true;
				}
				break;
			case 17:
				if(_g._hx_index == 8) {
					sheet.base.getSheet(sheet.sheet.name + "@" + old.name).sheet.props.isProps = false;
				}
				break;
			default:
			}
			old.type = c.type;
			old.typeStr = null;
		}
		if(old.opt != c.opt) {
			if(old.opt) {
				let _g = 0;
				let _g1 = sheet.getLines();
				while(_g < _g1.length) {
					let o = _g1[_g];
					++_g;
					let v = Reflect.field(o,c.name);
					if(v == null) {
						v = this.getDefault(c,null,sheet);
						if(v != null) {
							o[c.name] = v;
						}
					}
				}
			} else if(old.type._hx_index != 5) {
				let def = this.getDefault(old,null,sheet);
				let _g = 0;
				let _g1 = sheet.getLines();
				while(_g < _g1.length) {
					let o = _g1[_g];
					++_g;
					let v = Reflect.field(o,c.name);
					switch(c.type._hx_index) {
					case 8:
						if(v != null && v.length == 0) {
							Reflect.deleteField(o,c.name);
						}
						break;
					case 17:
						if(Reflect.fields(v).length == 0 || JSON.stringify(v) == JSON.stringify(def)) {
							Reflect.deleteField(o,c.name);
						}
						break;
					default:
						if(v == def) {
							Reflect.deleteField(o,c.name);
						}
					}
				}
			}
			old.opt = c.opt;
		}
		let v = Reflect.field(c,"display");
		if(v == null) {
			Reflect.deleteField(old,"display");
		} else {
			old["display"] = v;
		}
		let v1 = Reflect.field(c,"kind");
		if(v1 == null) {
			Reflect.deleteField(old,"kind");
		} else {
			old["kind"] = v1;
		}
		let v2 = Reflect.field(c,"scope");
		if(v2 == null) {
			Reflect.deleteField(old,"scope");
		} else {
			old["scope"] = v2;
		}
		let v3 = Reflect.field(c,"documentation");
		if(v3 == null) {
			Reflect.deleteField(old,"documentation");
		} else {
			old["documentation"] = v3;
		}
		let v4 = Reflect.field(c,"editor");
		if(v4 == null) {
			Reflect.deleteField(old,"editor");
		} else {
			old["editor"] = v4;
		}
		sheet.sync();
		return null;
	}
	makePairs(oldA,newA) {
		let pairs = [];
		let oldL = Lambda.list(oldA);
		let newL = Lambda.list(newA);
		let _g = 0;
		while(_g < oldA.length) {
			let a = oldA[_g];
			++_g;
			let _g_head = newL.h;
			while(_g_head != null) {
				let val = _g_head.item;
				_g_head = _g_head.next;
				if(a.name == val.name) {
					pairs.push({ a : a, b : val});
					oldL.remove(a);
					newL.remove(val);
					break;
				}
			}
		}
		let _g_head = oldL.h;
		while(_g_head != null) {
			let val = _g_head.item;
			_g_head = _g_head.next;
			let _g_head1 = newL.h;
			while(_g_head1 != null) {
				let val1 = _g_head1.item;
				_g_head1 = _g_head1.next;
				if(Lambda.indexOf(oldA,val) == Lambda.indexOf(newA,val1)) {
					pairs.push({ a : val, b : val1});
					oldL.remove(val);
					newL.remove(val1);
					break;
				}
			}
		}
		let _g_head1 = oldL.h;
		while(_g_head1 != null) {
			let val = _g_head1.item;
			_g_head1 = _g_head1.next;
			pairs.push({ a : val, b : null});
		}
		return pairs;
	}
	getConvFunction(old,t) {
		let conv = null;
		if(Type.enumEq(old,t)) {
			return { f : null};
		}
		switch(old._hx_index) {
		case 0:
			if(t._hx_index != 1) {
				return null;
			}
			break;
		case 1:
			switch(t._hx_index) {
			case 0:
				let r_invalid_r = new RegExp("[^A-Za-z0-9_]","g".split("u").join(""));
				conv = function(r) {
					return r.replace(r_invalid_r,"_");
				};
				break;
			case 2:
				conv = function(s) {
					return s != "";
				};
				break;
			case 3:
				conv = Std.parseInt;
				break;
			case 4:
				conv = function(str) {
					let f = parseFloat(str);
					if(isNaN(f)) {
						return null;
					} else {
						return f;
					}
				};
				break;
			case 5:
				let _g = t.values;
				let map_h = Object.create(null);
				let _g1 = 0;
				let _g2 = _g.length;
				while(_g1 < _g2) {
					let i = _g1++;
					map_h[_g[i].toLowerCase()] = i;
				}
				conv = function(s) {
					return map_h[s.toLowerCase()];
				};
				break;
			case 6:
				let r_invalid_r1 = new RegExp("[^A-Za-z0-9_]","g".split("u").join(""));
				conv = function(r) {
					return r.replace(r_invalid_r1,"_");
				};
				break;
			case 12:
				let r_invalid_r2 = new RegExp("[^A-Za-z0-9_]","g".split("u").join(""));
				conv = function(r) {
					return r.replace(r_invalid_r2,"_");
				};
				break;
			default:
				return null;
			}
			break;
		case 2:
			switch(t._hx_index) {
			case 1:
				conv = Std.string;
				break;
			case 3:case 4:
				conv = function(b) {
					if(b) {
						return 1;
					} else {
						return 0;
					}
				};
				break;
			default:
				return null;
			}
			break;
		case 3:
			switch(t._hx_index) {
			case 1:
				conv = Std.string;
				break;
			case 2:
				conv = function(v) {
					return v != 0;
				};
				break;
			case 4:
				break;
			case 5:
				let values = t.values;
				conv = function(i) {
					if(i < 0 || i >= values.length) {
						return null;
					} else {
						return i;
					}
				};
				break;
			case 11:
				conv = function(i) {
					return i;
				};
				break;
			default:
				return null;
			}
			break;
		case 4:
			switch(t._hx_index) {
			case 1:
				conv = Std.string;
				break;
			case 2:
				conv = function(v) {
					return v != 0;
				};
				break;
			case 3:
				conv = function(v) {
					return v | 0;
				};
				break;
			default:
				return null;
			}
			break;
		case 5:
			let _g3 = old.values;
			switch(t._hx_index) {
			case 1:
				let values1 = _g3;
				conv = function(i) {
					return values1[i];
				};
				break;
			case 3:
				break;
			case 5:
				let _g4 = t.values;
				let map = [];
				let _g5 = 0;
				let _g6 = [];
				let _g7 = 0;
				let _g8 = _g3.length;
				while(_g7 < _g8) {
					let i = _g7++;
					_g6.push({ name : _g3[i], i : i});
				}
				let _g9 = [];
				let _g10 = 0;
				let _g11 = _g4.length;
				while(_g10 < _g11) {
					let i = _g10++;
					_g9.push({ name : _g4[i], i : i});
				}
				let _g12 = this.makePairs(_g6,_g9);
				while(_g5 < _g12.length) {
					let p = _g12[_g5];
					++_g5;
					if(p.b == null) {
						continue;
					}
					map[p.a.i] = p.b.i;
				}
				conv = function(i) {
					return map[i];
				};
				break;
			case 10:
				if(Std.string(_g3) == Std.string(t.values)) {
					conv = function(i) {
						return 1 << i;
					};
				} else {
					return null;
				}
				break;
			default:
				return null;
			}
			break;
		case 6:
			if(t._hx_index != 1) {
				return null;
			}
			break;
		case 8:
			if(t._hx_index == 17) {
				conv = function(l) {
					return l[0];
				};
			} else {
				return null;
			}
			break;
		case 10:
			let _g13 = old.values;
			switch(t._hx_index) {
			case 3:
				break;
			case 10:
				let _g14 = t.values;
				let map1 = [];
				let _g15 = 0;
				let _g16 = [];
				let _g17 = 0;
				let _g18 = _g13.length;
				while(_g17 < _g18) {
					let i = _g17++;
					_g16.push({ name : _g13[i], i : i});
				}
				let _g19 = [];
				let _g20 = 0;
				let _g21 = _g14.length;
				while(_g20 < _g21) {
					let i = _g20++;
					_g19.push({ name : _g14[i], i : i});
				}
				let _g22 = this.makePairs(_g16,_g19);
				while(_g15 < _g22.length) {
					let p = _g22[_g15];
					++_g15;
					if(p.b == null) {
						continue;
					}
					map1[p.a.i] = p.b.i;
				}
				conv = function(i) {
					let out = 0;
					let k = 0;
					while(i >= 1 << k) {
						if(map1[k] != null && (i & 1 << k) != 0) {
							out |= 1 << map1[k];
						}
						++k;
					}
					return out;
				};
				break;
			default:
				return null;
			}
			break;
		case 11:
			if(t._hx_index == 3) {
				conv = function(i) {
					return i;
				};
			} else {
				return null;
			}
			break;
		case 12:
			if(t._hx_index != 1) {
				return null;
			}
			break;
		case 17:
			if(t._hx_index == 8) {
				conv = function(p) {
					if(Reflect.fields(p).length == 0) {
						return [];
					} else {
						return [p];
					}
				};
			} else {
				return null;
			}
			break;
		default:
			return null;
		}
		return { f : conv};
	}
	updateType(old,t) {
		let casesPairs = this.makePairs(old.cases,t.cases);
		let convMap = [];
		let convertTypeRec = null;
		let _gthis = this;
		convertTypeRec = function(t,v) {
			if(t == null || v == null) {
				return null;
			}
			let c = t.cases[v[0]];
			let _g = 0;
			let _g1 = c.args.length;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = c.args[i].type;
				if(_g1._hx_index == 9) {
					let av = v[i + 1];
					if(av != null) {
						v[i + 1] = convertTypeRec(_gthis.getCustomType(_g1.name),av);
					}
				}
			}
			if(t == old) {
				let conv = convMap[v[0]];
				if(conv == null) {
					return null;
				}
				let out = conv.def.slice();
				let _g = 0;
				let _g1 = conv.args.length;
				while(_g < _g1) {
					let i = _g++;
					let v1 = conv.args[i](v[i + 1]);
					if(v1 == null) {
						continue;
					}
					out[v1.index + 1] = v1.v;
				}
				return out;
			}
			return v;
		};
		let _g = 0;
		while(_g < casesPairs.length) {
			let p = casesPairs[_g];
			++_g;
			if(p.b == null) {
				continue;
			}
			let conv = { def : [Lambda.indexOf(t.cases,p.b)], args : []};
			let args = this.makePairs(p.a.args,p.b.args);
			let _g1 = 0;
			while(_g1 < args.length) {
				let a = args[_g1];
				++_g1;
				if(a.b == null) {
					conv.args[Lambda.indexOf(p.a.args,a.a)] = function(_) {
						return null;
					};
					continue;
				}
				let b = a.b;
				let a1 = a.a;
				let c = this.getConvFunction(a1.type,b.type);
				if(c == null) {
					throw haxe_Exception.thrown("Cannot convert " + p.a.name + "." + a1.name + ":" + this.typeStr(a1.type) + " to " + p.b.name + "." + b.name + ":" + this.typeStr(b.type));
				}
				let f = c.f;
				if(f == null) {
					f = function(x) {
						return x;
					};
				}
				if(a1.opt != b.opt) {
					let oldf = f;
					if(a1.opt) {
						f = function(v) {
							v = oldf(v);
							if(v == null) {
								return _gthis.getDefault(b);
							} else {
								return v;
							}
						};
					} else {
						let def = this.getDefault(a1);
						f = function(v) {
							if(v == def) {
								return null;
							} else {
								return oldf(v);
							}
						};
					}
				}
				if(a1.kind != b.kind) {
					a1.kind = b.kind;
					if(a1.kind == null) {
						Reflect.deleteField(a1,"kind");
					}
				}
				let index = Lambda.indexOf(p.b.args,b);
				conv.args[Lambda.indexOf(p.a.args,a1)] = function(v) {
					v = f(v);
					if(v == null && b.opt) {
						return null;
					} else {
						return { index : index, v : v};
					}
				};
			}
			let _g2 = 0;
			let _g3 = p.b.args;
			while(_g2 < _g3.length) conv.def.push(this.getDefault(_g3[_g2++]));
			while(conv.def[conv.def.length - 1] == null) conv.def.pop();
			convMap[Lambda.indexOf(old.cases,p.a)] = conv;
		}
		let _g1 = 0;
		let _g2 = this.sheets;
		while(_g1 < _g2.length) {
			let s = _g2[_g1];
			++_g1;
			let _g = 0;
			let _g3 = s.sheet.columns;
			while(_g < _g3.length) {
				let c = _g3[_g];
				++_g;
				let _g1 = c.type;
				if(_g1._hx_index == 9) {
					let _g = _g1.name;
					let t2 = this.getCustomType(_g);
					let _g2 = 0;
					let _g3 = s.getLines();
					while(_g2 < _g3.length) {
						let obj = _g3[_g2];
						++_g2;
						let v = Reflect.field(obj,c.name);
						if(v != null) {
							v = convertTypeRec(t2,v);
							if(v == null) {
								Reflect.deleteField(obj,c.name);
							} else {
								obj[c.name] = v;
							}
						}
					}
					if(_g == old.name && t.name != old.name) {
						c.type = cdb_ColumnType.TCustom(t.name);
						c.typeStr = null;
					}
				}
			}
		}
		if(t.name != old.name) {
			let _g = 0;
			let _g1 = this.getCustomTypes();
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = _g1[_g++].cases;
				while(_g2 < _g3.length) {
					let _g = 0;
					let _g1 = _g3[_g2++].args;
					while(_g < _g1.length) {
						let a = _g1[_g];
						++_g;
						let _g2 = a.type;
						if(_g2._hx_index == 9) {
							if(_g2.name == old.name) {
								a.type = cdb_ColumnType.TCustom(t.name);
								a.typeStr = null;
							}
						}
					}
				}
			}
			let key = old.name;
			let _this = this.tmap;
			if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
				delete(_this.h[key]);
			}
			old.name = t.name;
			this.tmap.h[old.name] = old;
		}
		old.cases = t.cases;
	}
	valToString(t,val,esc) {
		if(esc == null) {
			esc = false;
		}
		if(val == null) {
			return "null";
		}
		switch(t._hx_index) {
		case 1:
			let val1 = val;
			if(!esc) {
				return val1;
			} else {
				return "\"" + val1.split("\\").join("\\\\").split("\"").join("\\\"") + "\"";
			}
			break;
		case 5:
			return this.valToString(cdb_ColumnType.TString,t.values[val],esc);
		case 6:
			if(esc) {
				return "\"" + Std.string(val) + "\"";
			} else {
				return val;
			}
			break;
		case 2:case 3:case 4:case 7:
			return Std.string(val);
		case 8:case 17:
			return "???";
		case 9:
			return this.typeValToString(this.getCustomType(t.name),val,esc);
		case 10:
			let _g = t.values;
			let v = val;
			let flags = [];
			let _g1 = 0;
			let _g2 = _g.length;
			while(_g1 < _g2) {
				let i = _g1++;
				if((v & 1 << i) != 0) {
					flags.push(this.valToString(cdb_ColumnType.TString,_g[i],esc));
				}
			}
			return Std.string(flags);
		case 11:
			let s = "#" + StringTools.hex(val,6);
			if(esc) {
				return "\"" + s + "\"";
			} else {
				return s;
			}
			break;
		case 12:
			if(esc) {
				return "\"" + Std.string(val) + "\"";
			} else {
				return val;
			}
			break;
		case 0:case 13:
			if(esc) {
				return "\"" + Std.string(val) + "\"";
			} else {
				return val;
			}
			break;
		case 14:case 15:case 16:
			if(esc) {
				return JSON.stringify(val);
			}
			return this.valueToString(val);
		}
	}
	valueToString(v) {
		let _g = Type.typeof(v);
		switch(_g._hx_index) {
		case 0:
			return "null";
		case 4:
			let _g1 = [];
			let _g2 = 0;
			let _g3 = Reflect.fields(v);
			while(_g2 < _g3.length) {
				let f = _g3[_g2];
				++_g2;
				_g1.push(f + " : " + this.valueToString(Reflect.field(v,f)));
			}
			let fl = _g1;
			if(fl.length == 0) {
				return "{}";
			} else {
				return "{ " + fl.join(", ") + " }";
			}
			break;
		case 6:
			let c = _g.c;
			switch(c.__name__) {
			case "Array":
				let arr = v;
				let _g4 = [];
				let _g5 = 0;
				while(_g5 < arr.length) _g4.push(this.valueToString(arr[_g5++]));
				let vl = _g4;
				if(vl.length == 0) {
					return "[]";
				} else {
					return "[" + vl.join(", ") + "]";
				}
				break;
			case "String":
				return this.valToString(cdb_ColumnType.TString,v,true);
			default:
			}
			break;
		default:
		}
		return Std.string(v);
	}
	typeValToString(t,val,esc) {
		if(esc == null) {
			esc = false;
		}
		let c = t.cases[val[0]];
		let str = c.name;
		if(c.args.length > 0) {
			str += "(";
			let out = [];
			let _g = 1;
			let _g1 = val.length;
			while(_g < _g1) {
				let i = _g++;
				out.push(this.valToString(c.args[i - 1].type,val[i],esc));
			}
			str += out.join(",");
			str += ")";
		}
		return str;
	}
	parseDynamic(s) {
		let _this_r = new RegExp("([{,])[ \t\n]*([a-zA-Z_][a-zA-Z0-9_]*)[ \t\n]*:","g".split("u").join(""));
		s = s.replace(_this_r,"$1\"$2\":");
		return JSON.parse(s);
	}
	parseValue(t,val,strictCheck) {
		if(strictCheck == null) {
			strictCheck = false;
		}
		switch(t._hx_index) {
		case 0:
			if(this.r_ident.match(val)) {
				return val;
			}
			break;
		case 1:
			if(!strictCheck) {
				return val;
			}
			if(HxOverrides.cca(val,0) == 34) {
				let esc = false;
				let p = 1;
				let out_b = "";
				_hx_loop1: while(true) {
					if(p == val.length) {
						throw haxe_Exception.thrown("Unclosed \"");
					}
					let c = HxOverrides.cca(val,p++);
					if(esc) {
						out_b += String.fromCodePoint(c);
						esc = false;
					} else if(c == null) {
						out_b += String.fromCodePoint(c);
					} else {
						switch(c) {
						case 34:
							if(p < val.length) {
								throw haxe_Exception.thrown("Invalid content after string '" + val);
							}
							break _hx_loop1;
						case 92:
							esc = true;
							break;
						default:
							out_b += String.fromCodePoint(c);
						}
					}
				}
				return out_b;
			}
			if(!new EReg("^[A-Za-z0-9_]+$","").match(val)) {
				throw haxe_Exception.thrown("String requires quotes '" + val + "'");
			}
			return val;
		case 2:
			if(val == "true") {
				return true;
			}
			if(val == "false") {
				return false;
			}
			break;
		case 3:
			if(new EReg("^-?[0-9]+$","").match(val)) {
				return Std.parseInt(val);
			}
			break;
		case 4:
			let f = parseFloat(val);
			if(!isNaN(f)) {
				return f;
			}
			break;
		case 6:
			let t1 = t.sheet;
			if(this.r_ident.match(val)) {
				if(!strictCheck) {
					return val;
				}
				let r = this.getSheet(t1).index.h[val];
				if(r == null) {
					throw haxe_Exception.thrown(val + " is not a known " + t1 + " id");
				}
				return r.id;
			}
			break;
		case 9:
			return this.parseTypeVal(this.getCustomType(t.name),val);
		case 11:
			if(val.charAt(0) == "#") {
				val = "0x" + HxOverrides.substr(val,1,null);
			}
			if(new EReg("^-?[0-9]+$","").match(val) || new EReg("^0x[0-9A-Fa-f]+$","").match(val)) {
				return Std.parseInt(val);
			}
			break;
		case 16:
			return this.parseDynamic(val);
		default:
		}
		throw haxe_Exception.thrown("'" + val + "' should be " + this.typeStr(t));
	}
	parseTypeVal(t,val) {
		if(t == null || val == null) {
			throw haxe_Exception.thrown("Missing val/type");
		}
		val = StringTools.trim(val);
		let missingCloseParent = false;
		let pos = val.indexOf("(");
		let id;
		let args = null;
		if(pos < 0) {
			id = val;
			args = [];
		} else {
			id = HxOverrides.substr(val,0,pos);
			val = HxOverrides.substr(val,pos + 1,null);
			if(val.endsWith(")")) {
				val = HxOverrides.substr(val,0,val.length - 1);
			} else {
				missingCloseParent = true;
			}
			args = [];
			let p = 0;
			let start = 0;
			let pc = 0;
			while(p < val.length) {
				let _g = HxOverrides.cca(val,p++);
				if(_g != null) {
					switch(_g) {
					case 34:
						let esc = false;
						_hx_loop2: while(true) {
							if(p == val.length) {
								throw haxe_Exception.thrown("Unclosed \"");
							}
							let index = p++;
							if(esc) {
								esc = false;
							} else {
								switch(HxOverrides.cca(val,index)) {
								case 34:
									break _hx_loop2;
								case 92:
									esc = true;
									break;
								}
							}
						}
						break;
					case 40:
						++pc;
						break;
					case 41:
						if(pc == 0) {
							throw haxe_Exception.thrown("Extra )");
						}
						--pc;
						break;
					case 44:
						if(pc == 0) {
							args.push(HxOverrides.substr(val,start,p - start - 1));
							start = p;
						}
						break;
					default:
					}
				}
			}
			if(pc > 0) {
				missingCloseParent = true;
			}
			if(p > start || start > 0 && p == start) {
				args.push(HxOverrides.substr(val,start,p - start));
			}
		}
		let _g = 0;
		let _g1 = t.cases.length;
		while(_g < _g1) {
			let i = _g++;
			let c = t.cases[i];
			if(c.name == id) {
				let vals = [i];
				let _g = 0;
				let _g1 = c.args;
				while(_g < _g1.length) {
					let a = _g1[_g];
					++_g;
					let v = args.shift();
					if(v == null) {
						if(a.opt) {
							vals.push(null);
						} else {
							throw haxe_Exception.thrown("Missing argument " + a.name + " : " + this.typeStr(a.type));
						}
					} else {
						v = StringTools.trim(v);
						if(a.opt && v == "null") {
							vals.push(null);
							continue;
						}
						let val;
						try {
							val = this.parseValue(a.type,v,true);
						} catch( _g ) {
							let _g1 = haxe_Exception.caught(_g).unwrap();
							if(typeof(_g1) == "string") {
								throw haxe_Exception.thrown(_g1 + " for " + a.name);
							} else {
								throw _g;
							}
						}
						vals.push(val);
					}
				}
				if(args.length > 0) {
					throw haxe_Exception.thrown("Extra argument '" + args.shift() + "'");
				}
				if(missingCloseParent) {
					throw haxe_Exception.thrown("Missing )");
				}
				while(vals[vals.length - 1] == null) vals.pop();
				return vals;
			}
		}
		throw haxe_Exception.thrown("Unkown value '" + id + "'");
	}
	parseType(tstr) {
		switch(tstr) {
		case "Bool":
			return cdb_ColumnType.TBool;
		case "Float":
			return cdb_ColumnType.TFloat;
		case "Int":
			return cdb_ColumnType.TInt;
		case "String":
			return cdb_ColumnType.TString;
		default:
			if(this.getCustomType(tstr) != null) {
				return cdb_ColumnType.TCustom(tstr);
			} else if(this.getSheet(tstr) != null) {
				return cdb_ColumnType.TRef(tstr);
			} else {
				if(tstr.endsWith(">")) {
					tstr.split("<").shift();
				}
				throw haxe_Exception.thrown("Unknown type " + tstr);
			}
		}
	}
	typeCasesToString(t,prefix) {
		if(prefix == null) {
			prefix = "";
		}
		let arr = [];
		let _g = 0;
		let _g1 = t.cases;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let str = c.name;
			if(c.args.length > 0) {
				str += "( ";
				let out = [];
				let _g = 0;
				let _g1 = c.args;
				while(_g < _g1.length) {
					let a = _g1[_g];
					++_g;
					let k = "";
					if(a.opt) {
						k = "?";
					}
					k += a.name + " : " + this.typeStr(a.type);
					if(a.kind == "typekind") {
						k += "Kind";
					}
					out.push(k);
				}
				str += out.join(", ");
				str += " )";
			}
			str += ";";
			arr.push(prefix + str);
		}
		return arr.join("\n");
	}
	parseTypeCases(def) {
		let cases = [];
		let cmap_h = Object.create(null);
		let _g = 0;
		let _g1 = new EReg("[\n;]","g").split(def);
		while(_g < _g1.length) {
			let line = StringTools.trim(_g1[_g++]);
			if(line == "") {
				continue;
			}
			if(HxOverrides.cca(line,line.length - 1) == 59) {
				line = HxOverrides.substr(line,1,null);
			}
			let pos = line.indexOf("(");
			let name = null;
			let args = [];
			if(pos < 0) {
				name = line;
			} else {
				name = HxOverrides.substr(line,0,pos);
				line = HxOverrides.substr(line,pos + 1,null);
				if(HxOverrides.cca(line,line.length - 1) != 41) {
					throw haxe_Exception.thrown("Missing closing parent in " + line);
				}
				line = HxOverrides.substr(line,0,line.length - 1);
				let _g = 0;
				let _g1 = line.split(",");
				while(_g < _g1.length) {
					let arg = _g1[_g];
					++_g;
					let tname = arg.split(":");
					if(tname.length != 2) {
						throw haxe_Exception.thrown("Required name:type in '" + arg + "'");
					}
					let opt = false;
					let isKind = false;
					let id = StringTools.trim(tname[0]);
					if(id.charAt(0) == "?") {
						opt = true;
						id = StringTools.trim(HxOverrides.substr(id,1,null));
					}
					let t = StringTools.trim(tname[1]);
					if(t.endsWith("Kind") && this.getSheet(HxOverrides.substr(t,0,-4)) != null) {
						isKind = true;
						t = HxOverrides.substr(t,0,-4);
					}
					if(!this.r_ident.match(id)) {
						throw haxe_Exception.thrown("Invalid identifier " + id);
					}
					let c = { name : id, type : this.parseType(t), typeStr : null};
					if(opt) {
						c.opt = true;
					}
					if(isKind) {
						c.kind = "typekind";
					}
					args.push(c);
				}
			}
			if(!this.r_ident.match(name)) {
				throw haxe_Exception.thrown("Invalid identifier " + line);
			}
			if(Object.prototype.hasOwnProperty.call(cmap_h,name)) {
				throw haxe_Exception.thrown("Duplicate identifier " + name);
			}
			cmap_h[name] = true;
			cases.push({ name : name, args : args});
		}
		return cases;
	}
	mapType(callb) {
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) {
			let _g2 = 0;
			let _g3 = _g1[_g++].sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				let t = callb(c.type);
				if(t != c.type) {
					c.type = t;
					c.typeStr = null;
				}
			}
		}
		let _g2 = 0;
		let _g3 = this.getCustomTypes();
		while(_g2 < _g3.length) {
			let _g = 0;
			let _g1 = _g3[_g2++].cases;
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = _g1[_g++].args;
				while(_g2 < _g3.length) {
					let a = _g3[_g2];
					++_g2;
					let t = callb(a.type);
					if(t != a.type) {
						a.type = t;
						a.typeStr = null;
					}
				}
			}
		}
	}
	convertTypeRec(sheet,refMap,t,o) {
		let c = t.cases[o[0]];
		let _g = 0;
		let _g1 = o.length - 1;
		while(_g < _g1) {
			let i = _g++;
			let v = o[i + 1];
			if(v == null) {
				continue;
			}
			let _g1 = c.args[i].type;
			switch(_g1._hx_index) {
			case 6:
				if(_g1.sheet == sheet.sheet.name) {
					let v1 = refMap.h[v];
					if(v1 == null) {
						continue;
					}
					o[i + 1] = v1;
				}
				break;
			case 9:
				this.convertTypeRec(sheet,refMap,this.getCustomType(_g1.name),v);
				break;
			default:
			}
		}
	}
	replaceScriptIdent(v,oldId,newId) {
		let _this_r = new RegExp("\\b" + oldId.split(".").join("\\.") + "\\b","".split("u").join(""));
		return v.replace(_this_r,newId);
	}
	updateLocalRefs(sheet,refMap,obj,objSheet) {
		let _g = 0;
		let _g1 = objSheet.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let v = Reflect.field(obj,c.name);
			if(v == null) {
				continue;
			}
			let _g2 = c.type;
			switch(_g2._hx_index) {
			case 1:
				if(c.kind == "script") {
					let prefix = sheet.sheet.name.split("@").pop();
					prefix = prefix.charAt(0).toUpperCase() + HxOverrides.substr(prefix,1,null);
					let h = refMap.h;
					let _g_keys = Object.keys(h);
					let _g_length = _g_keys.length;
					let _g_current = 0;
					while(_g_current < _g_length) {
						let key = _g_keys[_g_current++];
						let _g_value = h[key];
						if(key != "" && _g_value != "") {
							v = this.replaceScriptIdent(v,prefix + "." + key,prefix + "." + _g_value);
						}
					}
					obj[c.name] = v;
				}
				break;
			case 6:
				if(_g2.sheet == sheet.sheet.name) {
					v = refMap.h[v];
					if(v == null) {
						continue;
					}
					obj[c.name] = v;
				}
				break;
			case 8:
				let sub = objSheet.base.getSheet(objSheet.sheet.name + "@" + c.name);
				let _g3 = 0;
				let _g4 = v;
				while(_g3 < _g4.length) this.updateLocalRefs(sheet,refMap,_g4[_g3++],sub);
				break;
			case 9:
				this.convertTypeRec(sheet,refMap,this.getCustomType(_g2.name),v);
				break;
			case 17:
				this.updateLocalRefs(sheet,refMap,v,objSheet.base.getSheet(objSheet.sheet.name + "@" + c.name));
				break;
			default:
			}
		}
	}
	updateRefs(sheet,refMap) {
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = s.sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				let _g = c.type;
				switch(_g._hx_index) {
				case 1:
					if(c.kind == "script") {
						let prefix = sheet.sheet.name.split("@").pop();
						prefix = prefix.charAt(0).toUpperCase() + HxOverrides.substr(prefix,1,null);
						let _g = 0;
						let _g1 = s.getLines();
						while(_g < _g1.length) {
							let obj = _g1[_g];
							++_g;
							let v = Reflect.field(obj,c.name);
							if(v != null) {
								let h = refMap.h;
								let _g_keys = Object.keys(h);
								let _g_length = _g_keys.length;
								let _g_current = 0;
								while(_g_current < _g_length) {
									let key = _g_keys[_g_current++];
									let _g_value = h[key];
									if(key != "" && _g_value != "") {
										v = this.replaceScriptIdent(v,prefix + "." + key,prefix + "." + _g_value);
									}
								}
								obj[c.name] = v;
							}
						}
					}
					break;
				case 6:
					if(_g.sheet == sheet.sheet.name) {
						let _g = 0;
						let _g1 = s.getLines();
						while(_g < _g1.length) {
							let obj = _g1[_g];
							++_g;
							let id = Reflect.field(obj,c.name);
							if(id == null) {
								continue;
							}
							id = refMap.h[id];
							if(id == null) {
								continue;
							}
							obj[c.name] = id;
						}
					}
					break;
				case 9:
					let _g1 = _g.name;
					let _g4 = 0;
					let _g5 = s.getLines();
					while(_g4 < _g5.length) {
						let o = Reflect.field(_g5[_g4++],c.name);
						if(o == null) {
							continue;
						}
						this.convertTypeRec(sheet,refMap,this.getCustomType(_g1),o);
					}
					break;
				default:
				}
			}
		}
	}
	updateSheets() {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.sheets;
		while(_g1 < _g2.length) _g.push(_g2[_g1++].sheet);
		this.data.sheets = _g;
	}
	deleteSheet(sheet,removeData) {
		if(removeData == null) {
			removeData = true;
		}
		HxOverrides.remove(this.sheets,sheet);
		if(removeData) {
			this.updateSheets();
		}
		let key = sheet.sheet.name;
		let _this = this.smap;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
		}
		let _g = 0;
		let _g1 = sheet.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			switch(c.type._hx_index) {
			case 8:case 17:
				this.deleteSheet(sheet.base.getSheet(sheet.sheet.name + "@" + c.name),removeData);
				break;
			default:
			}
		}
		this.mapType(function(t) {
			switch(t._hx_index) {
			case 6:
				if(t.sheet == sheet.sheet.name) {
					return cdb_ColumnType.TString;
				} else {
					return t;
				}
				break;
			case 12:
				if(t.type == sheet.sheet.name) {
					return cdb_ColumnType.TString;
				} else {
					return t;
				}
				break;
			default:
				return t;
			}
		});
	}
	syncbackData() {
		let _g = 0;
		let _g1 = this.sheets;
		while(_g < _g1.length) this.deleteSheet(_g1[_g++],false);
		let _g2 = 0;
		let _g3 = this.data.sheets;
		while(_g2 < _g3.length) {
			let s = _g3[_g2];
			++_g2;
			let sobj = new cdb_Sheet(this,s);
			sobj.sync();
			this.sheets.splice(this.data.sheets.indexOf(s),0,sobj);
		}
		this.save();
	}
}
cdb_Database.__name__ = "cdb.Database";
Object.assign(cdb_Database.prototype, {
	__class__: cdb_Database
});
class cdb_Lz4Reader {
	constructor() {
	}
	b() {
		return this.bytes.b[this.pos++];
	}
	grow(out,pos,len) {
		let size = out.length;
		do size = size * 3 >> 1; while(size < pos + len);
		let out2 = new haxe_io_Bytes(new ArrayBuffer(size));
		out2.blit(0,out,0,pos);
		return out2;
	}
	read(bytes) {
		this.bytes = bytes;
		this.pos = 0;
		if(this.bytes.b[this.pos++] != 4 || this.bytes.b[this.pos++] != 34 || this.bytes.b[this.pos++] != 77 || this.bytes.b[this.pos++] != 24) {
			throw haxe_Exception.thrown("Invalid header");
		}
		let flags = this.bytes.b[this.pos++];
		if(flags >> 6 != 1) {
			throw haxe_Exception.thrown("Invalid version " + (flags >> 6));
		}
		let blockChecksum = (flags & 16) != 0;
		if((flags & 2) != 0) {
			throw haxe_Exception.thrown("assert");
		}
		let bd = this.bytes.b[this.pos++];
		if((bd & 128) != 0) {
			throw haxe_Exception.thrown("assert");
		}
		if([0,0,0,0,65536,262144,1048576,4194304][bd >> 4 & 7] == 0) {
			throw haxe_Exception.thrown("assert");
		}
		if((bd & 15) != 0) {
			throw haxe_Exception.thrown("assert");
		}
		if((flags & 8) != 0) {
			this.pos += 8;
		}
		if((flags & 1) != 0) {
			throw haxe_Exception.thrown("Preset dictionary not supported");
		}
		this.pos++;
		let out = new haxe_io_Bytes(new ArrayBuffer(128));
		let outPos = 0;
		while(true) {
			let size = this.bytes.b[this.pos++] | this.bytes.b[this.pos++] << 8 | this.bytes.b[this.pos++] << 16 | this.bytes.b[this.pos++] << 24;
			if(size == 0) {
				break;
			}
			if((size & -16) == 407710288) {
				let dataSize = this.bytes.b[this.pos++] | this.bytes.b[this.pos++] << 8 | this.bytes.b[this.pos++] << 16 | this.bytes.b[this.pos++] << 24;
				this.pos += dataSize;
				continue;
			}
			if((size & -2147483648) != 0) {
				size &= 2147483647;
				if(outPos + out.length < size) {
					out = this.grow(out,outPos,size);
				}
				out.blit(outPos,bytes,this.pos,size);
				outPos += size;
				this.pos += size;
			} else {
				let srcEnd = this.pos + size;
				while(this.pos < srcEnd) {
					let r = cdb_Lz4Reader.uncompress(bytes,this.pos,srcEnd - this.pos,out,outPos);
					this.pos = r[0];
					outPos = r[1];
					let req = r[2];
					if(req > 0) {
						out = this.grow(out,outPos,req);
					}
				}
			}
			if(blockChecksum) {
				this.pos += 4;
			}
		}
		return out.sub(0,outPos);
	}
	static uncompress(src,srcPos,srcLen,out,outPos) {
		let srcEnd = srcPos + srcLen;
		if(srcLen == 0) {
			return [srcPos,outPos,0];
		}
		let outLen = out.length;
		while(true) {
			let start = srcPos;
			let tk = src.b[srcPos++];
			let litLen = tk >> 4;
			let matchLen = tk & 15;
			if(litLen == 15) {
				let b;
				do {
					b = src.b[srcPos++];
					litLen += b;
				} while(b == 255);
			}
			if(outPos + litLen > outLen) {
				return [start,outPos,litLen + matchLen];
			}
			switch(litLen) {
			case 0:
				break;
			case 1:
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				break;
			case 2:
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				break;
			case 3:
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				out.b[outPos] = src.b[srcPos++];
				++outPos;
				break;
			default:
				out.blit(outPos,src,srcPos,litLen);
				outPos += litLen;
				srcPos += litLen;
			}
			if(srcPos >= srcEnd) {
				break;
			}
			let offset = src.b[srcPos++];
			offset |= src.b[srcPos++] << 8;
			if(matchLen == 15) {
				let b;
				do {
					b = src.b[srcPos++];
					matchLen += b;
				} while(b == 255);
			}
			matchLen += 4;
			if(outPos + matchLen > outLen) {
				return [start,outPos - litLen,litLen + matchLen];
			}
			if(matchLen >= 64 && matchLen <= offset) {
				out.blit(outPos,out,outPos - offset,matchLen);
				outPos += matchLen;
			} else {
				let copyEnd = outPos + matchLen;
				while(outPos < copyEnd) {
					out.b[outPos] = out.b[outPos - offset];
					++outPos;
				}
			}
		}
		if(srcPos != srcEnd) {
			throw haxe_Exception.thrown("Read too much data " + (srcPos - srcLen));
		}
		return [srcPos,outPos,0];
	}
	static decodeString(s) {
		if(s == "") {
			return new haxe_io_Bytes(new ArrayBuffer(0));
		}
		let k = haxe_crypto_Base64.decode(s);
		if(k.b[0] != 4 || k.b[1] != 34 || k.b[2] != 77 || k.b[3] != 24) {
			return k;
		}
		let tmp = new Uint8Array(k.length);
		let _g = 0;
		let _g1 = k.length;
		while(_g < _g1) {
			let i = _g++;
			tmp[i] = k.b[i];
		}
		let k1 = lz4.decompress(tmp);
		let b = new haxe_io_Bytes(new ArrayBuffer(k1.length));
		let _g2 = 0;
		let _g3 = k1.length;
		while(_g2 < _g3) {
			let i = _g2++;
			b.b[i] = k1[i];
		}
		return b;
	}
	static encodeBytes(b,compress) {
		if(compress && b.length > 0) {
			let tmp = new Uint8Array(b.length);
			let _g = 0;
			let _g1 = b.length;
			while(_g < _g1) {
				let i = _g++;
				tmp[i] = b.b[i];
			}
			tmp = lz4.compress(tmp,65536);
			b = new haxe_io_Bytes(new ArrayBuffer(tmp.length));
			let _g2 = 0;
			let _g3 = tmp.length;
			while(_g2 < _g3) {
				let i = _g2++;
				b.b[i] = tmp[i];
			}
		}
		return haxe_crypto_Base64.encode(b);
	}
}
cdb_Lz4Reader.__name__ = "cdb.Lz4Reader";
Object.assign(cdb_Lz4Reader.prototype, {
	__class__: cdb_Lz4Reader
});
class cdb_Parser {
	static saveType(t) {
		switch(t._hx_index) {
		case 5:
			return t._hx_index + ":" + t.values.join(",");
		case 6:
			return t._hx_index + ":" + Std.string(Type.enumParameters(t)[0]);
		case 9:
			return t._hx_index + ":" + Std.string(Type.enumParameters(t)[0]);
		case 10:
			return t._hx_index + ":" + t.values.join(",");
		case 12:
			return t._hx_index + ":" + Std.string(Type.enumParameters(t)[0]);
		case 0:case 1:case 2:case 3:case 4:case 7:case 8:case 11:case 13:case 14:case 15:case 16:case 17:
			if(t._hx_index == null) {
				return "null";
			} else {
				return "" + t._hx_index;
			}
			break;
		}
	}
	static getType(str) {
		let _g = Std.parseInt(str);
		if(_g == null) {
			throw haxe_Exception.thrown("Unknown type " + str);
		} else {
			switch(_g) {
			case 0:
				return cdb_ColumnType.TId;
			case 1:
				return cdb_ColumnType.TString;
			case 2:
				return cdb_ColumnType.TBool;
			case 3:
				return cdb_ColumnType.TInt;
			case 4:
				return cdb_ColumnType.TFloat;
			case 5:
				return cdb_ColumnType.TEnum(HxOverrides.substr(str,str.indexOf(":") + 1,null).split(","));
			case 6:
				return cdb_ColumnType.TRef(HxOverrides.substr(str,str.indexOf(":") + 1,null));
			case 7:
				return cdb_ColumnType.TImage;
			case 8:
				return cdb_ColumnType.TList;
			case 9:
				return cdb_ColumnType.TCustom(HxOverrides.substr(str,str.indexOf(":") + 1,null));
			case 10:
				return cdb_ColumnType.TFlags(HxOverrides.substr(str,str.indexOf(":") + 1,null).split(","));
			case 11:
				return cdb_ColumnType.TColor;
			case 12:
				return cdb_ColumnType.TLayer(HxOverrides.substr(str,str.indexOf(":") + 1,null));
			case 13:
				return cdb_ColumnType.TFile;
			case 14:
				return cdb_ColumnType.TTilePos;
			case 15:
				return cdb_ColumnType.TTileLayer;
			case 16:
				return cdb_ColumnType.TDynamic;
			case 17:
				return cdb_ColumnType.TProperties;
			default:
				throw haxe_Exception.thrown("Unknown type " + str);
			}
		}
	}
	static parse(content,editMode) {
		if(content == null) {
			throw haxe_Exception.thrown("CDB content is null");
		}
		let data = JSON.parse(content);
		let _g = 0;
		let _g1 = data.sheets;
		while(_g < _g1.length) {
			let _g2 = 0;
			let _g3 = _g1[_g++].columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				c.type = cdb_Parser.getType(c.typeStr);
				c.typeStr = null;
			}
		}
		let _g2 = 0;
		let _g3 = data.customTypes;
		while(_g2 < _g3.length) {
			let _g = 0;
			let _g1 = _g3[_g2++].cases;
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = _g1[_g++].args;
				while(_g2 < _g3.length) {
					let a = _g3[_g2];
					++_g2;
					a.type = cdb_Parser.getType(a.typeStr);
					a.typeStr = null;
				}
			}
		}
		let _g4 = 0;
		let _g5 = data.sheets;
		while(_g4 < _g5.length) {
			let s = _g5[_g4];
			++_g4;
			if(!(editMode || s.props.hasGroup)) {
				continue;
			}
			if(s.separators == null) {
				let ids = Reflect.field(s,"separatorIds");
				let _g = [];
				let _g1 = 0;
				while(_g1 < ids.length) {
					let i = ids[_g1];
					++_g1;
					if(typeof(i) == "number" && ((i | 0) === i)) {
						_g.push({ index : i});
					} else {
						_g.push({ id : i});
					}
				}
				s.separators = _g;
				Reflect.deleteField(s,"separatorIds");
			}
			let indexMap = null;
			let _g = 0;
			let _g1 = s.separators.length;
			while(_g < _g1) {
				let i = _g++;
				let sep = s.separators[i];
				if(typeof(sep) == "number" && ((sep | 0) === sep)) {
					s.separators[i] = { index : sep};
				} else if(sep.id != null) {
					if(indexMap == null) {
						let idField = null;
						let _g = 0;
						let _g1 = s.columns;
						while(_g < _g1.length) {
							let c = _g1[_g];
							++_g;
							if(c.type == cdb_ColumnType.TId) {
								idField = c.name;
								break;
							}
						}
						indexMap = new haxe_ds_StringMap();
						let _g2 = 0;
						let _g3 = s.lines.length;
						while(_g2 < _g3) {
							let i = _g2++;
							let id = Reflect.field(s.lines[i],idField);
							if(id != null) {
								indexMap.h[id] = i;
							}
						}
					}
					sep.index = indexMap.h[sep.id];
					Reflect.deleteField(sep,"id");
				}
			}
			let titles = Reflect.field(s.props,"separatorTitles");
			if(titles != null) {
				Reflect.deleteField(s.props,"separatorTitles");
				let _g = 0;
				let _g1 = titles.length;
				while(_g < _g1) {
					let i = _g++;
					if(titles[i] != null) {
						s.separators[i].title = titles[i];
					}
				}
			}
		}
		return data;
	}
	static save(data) {
		let save = [];
		let seps = [];
		let _g = 0;
		let _g1 = data.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let idField = null;
			let _g2 = 0;
			let _g3 = s.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				if(c.type == cdb_ColumnType.TId && idField == null) {
					idField = c.name;
				}
				save.push(c.type);
				if(c.typeStr == null) {
					c.typeStr = cdb_Parser.saveType(c.type);
				}
				Reflect.deleteField(c,"type");
			}
			let oldSeps = null;
			if(idField != null && s.separators.length > 0) {
				let uniqueIDs = true;
				let uids_h = Object.create(null);
				let _g = 0;
				let _g1 = s.lines;
				while(_g < _g1.length) {
					let id = Reflect.field(_g1[_g++],idField);
					if(id != null) {
						if(uids_h[id]) {
							uniqueIDs = false;
							break;
						}
						uids_h[id] = true;
					}
				}
				if(uniqueIDs) {
					oldSeps = s.separators;
					s.separators = [];
					let _g = 0;
					while(_g < oldSeps.length) {
						let sep = oldSeps[_g];
						++_g;
						let obj = s.lines[sep.index];
						let id = obj != null ? Reflect.field(obj,idField) : null;
						let sep1 = sep;
						if(id != null) {
							sep1 = Reflect.copy(sep);
							Reflect.deleteField(sep1,"index");
							sep1.id = id;
						}
						s.separators.push(sep1);
					}
				}
			}
			seps.push(oldSeps);
		}
		let _g2 = 0;
		let _g3 = data.customTypes;
		while(_g2 < _g3.length) {
			let _g = 0;
			let _g1 = _g3[_g2++].cases;
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = _g1[_g++].args;
				while(_g2 < _g3.length) {
					let a = _g3[_g2];
					++_g2;
					save.push(a.type);
					if(a.typeStr == null) {
						a.typeStr = cdb_Parser.saveType(a.type);
					}
					Reflect.deleteField(a,"type");
				}
			}
		}
		let str = JSON.stringify(data,null,"\t");
		let _g4 = 0;
		let _g5 = data.sheets;
		while(_g4 < _g5.length) {
			let s = _g5[_g4];
			++_g4;
			let _g = 0;
			let _g1 = s.columns;
			while(_g < _g1.length) _g1[_g++].type = save.shift();
			let oldSeps = seps.shift();
			if(oldSeps != null) {
				s.separators = oldSeps;
			}
		}
		let _g6 = 0;
		let _g7 = data.customTypes;
		while(_g6 < _g7.length) {
			let _g = 0;
			let _g1 = _g7[_g6++].cases;
			while(_g < _g1.length) {
				let _g2 = 0;
				let _g3 = _g1[_g++].args;
				while(_g2 < _g3.length) _g3[_g2++].type = save.shift();
			}
		}
		return str;
	}
}
cdb_Parser.__name__ = "cdb.Parser";
class cdb_Sheet {
	constructor(base,sheet,path,parent) {
		this.uid = cdb_Sheet._UID++;
		this.base = base;
		this.sheet = sheet;
		this.path = path;
		this.parent = parent;
		this.sheetType = sheet.sheetType;
		this.realSheet = this;
	}
	get_lines() {
		return this.sheet.lines;
	}
	get_props() {
		return this.sheet.props;
	}
	get_columns() {
		return this.sheet.columns;
	}
	get_name() {
		return this.sheet.name;
	}
	get_separators() {
		return this.sheet.separators;
	}
	isLevel() {
		return this.sheet.props.level != null;
	}
	getSub(c) {
		return this.base.getSheet(this.sheet.name + "@" + c.name);
	}
	getParent() {
		if(!this.sheet.props.hide) {
			return null;
		}
		let parts = this.sheet.name.split("@");
		let colName = parts.pop();
		return { s : this.base.getSheet(parts.join("@")), c : colName};
	}
	getLines(scope) {
		if(scope == null) {
			scope = -1;
		}
		let p = this.getParent();
		if(p == null) {
			if(this.sheet.lines == null && this.sheet.props.dataFiles != null) {
				return [];
			}
			if(scope == 0) {
				let cname = this.idCol == null ? "" : this.idCol.name;
				let _g = [];
				let _g1 = 0;
				let _g2 = this.sheet.lines;
				while(_g1 < _g2.length) {
					let l = _g2[_g1];
					++_g1;
					_g.push({ id : Reflect.field(l,cname), obj : l});
				}
				return _g;
			}
			return this.sheet.lines;
		}
		if(p.s.sheet.props.level != null && p.c == "tileProps") {
			if(scope == 0) {
				throw haxe_Exception.thrown("TODO");
			}
			let all = [];
			let sets = p.s.sheet.props.level.tileSets;
			let _g = 0;
			let _g1 = Reflect.fields(sets);
			while(_g < _g1.length) {
				let t = Reflect.field(sets,_g1[_g++]);
				if(t.props == null) {
					continue;
				}
				let _g2 = 0;
				let _g3 = t.props;
				while(_g2 < _g3.length) {
					let p = _g3[_g2];
					++_g2;
					if(p != null) {
						all.push(p);
					}
				}
			}
			return all;
		}
		let all = [];
		let parentScope = scope - 1;
		if(scope == 0 && this.idCol.scope != null) {
			parentScope = this.idCol.scope - 1;
		}
		if(this.sheet.props.isProps) {
			let _g = 0;
			let _g1 = p.s.getLines(parentScope);
			while(_g < _g1.length) {
				let obj = _g1[_g];
				++_g;
				let v = Reflect.field(parentScope >= 0 ? obj.obj : obj,p.c);
				if(v != null) {
					let tmp;
					if(scope >= 0) {
						let id = parentScope >= 0 ? obj.id : null;
						if(scope == 0) {
							let locId = this.idCol != null ? Reflect.field(v,this.idCol.name) : null;
							if(locId == null) {
								id = null;
							} else if(parentScope >= 0) {
								if(id != null) {
									id = id + ":" + locId;
								}
							} else {
								id = locId;
							}
						}
						tmp = { id : id, obj : v};
					} else {
						tmp = v;
					}
					all.push(tmp);
				}
			}
		} else {
			let _g = 0;
			let _g1 = p.s.getLines(parentScope);
			while(_g < _g1.length) {
				let obj = _g1[_g];
				++_g;
				let arr = Reflect.field(parentScope >= 0 ? obj.obj : obj,p.c);
				if(arr != null) {
					let _g = 0;
					while(_g < arr.length) {
						let v = arr[_g];
						++_g;
						let tmp;
						if(scope >= 0) {
							let id = parentScope >= 0 ? obj.id : null;
							if(scope == 0) {
								let locId = this.idCol != null ? Reflect.field(v,this.idCol.name) : null;
								if(locId == null) {
									id = null;
								} else if(parentScope >= 0) {
									if(id != null) {
										id = id + ":" + locId;
									}
								} else {
									id = locId;
								}
							}
							tmp = { id : id, obj : v};
						} else {
							tmp = v;
						}
						all.push(tmp);
					}
				}
			}
		}
		return all;
	}
	getObjects() {
		let p = this.getParent();
		if(p == null) {
			let _g = [];
			let _g1 = 0;
			let _g2 = this.sheet.lines.length;
			while(_g1 < _g2) {
				let i = _g1++;
				_g.push({ path : [this.sheet.lines[i]], indexes : [i]});
			}
			return _g;
		}
		let all = [];
		let _g = 0;
		let _g1 = p.s.getObjects();
		while(_g < _g1.length) {
			let obj = _g1[_g];
			++_g;
			let v = Reflect.field(obj.path[obj.path.length - 1],p.c);
			if(v == null) {
				continue;
			}
			if(((v) instanceof Array)) {
				let v1 = v;
				let _g = 0;
				let _g1 = v1.length;
				while(_g < _g1) {
					let i = _g++;
					let sobj = v1[i];
					let p = obj.path.slice();
					let idx = obj.indexes.slice();
					p.push(sobj);
					idx.push(i);
					all.push({ path : p, indexes : idx});
				}
			} else {
				let p = obj.path.slice();
				let idx = obj.indexes.slice();
				p.push(v);
				idx.push(-1);
				all.push({ path : p, indexes : idx});
			}
		}
		return all;
	}
	newLine(index) {
		let o = { };
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let d = this.base.getDefault(c,null,this);
			if(d != null) {
				o[c.name] = d;
			}
		}
		if(index == null) {
			this.sheet.lines.push(o);
		} else {
			let _g = 0;
			let _g1 = this.sheet.separators;
			while(_g < _g1.length) {
				let s = _g1[_g];
				++_g;
				if(s.index > index) {
					s.index++;
				}
			}
			this.sheet.lines.splice(index + 1,0,o);
			let _g2 = [];
			let _g3 = 0;
			let _g4 = this.sheet.lines.length;
			while(_g3 < _g4) {
				let i = _g3++;
				_g2.push(i <= index ? i : i + 1);
			}
			this.changeLineOrder(_g2);
		}
		return o;
	}
	updateLine(index,toCopy) {
		let line = this.sheet.lines[index];
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			line[c.name] = Reflect.field(toCopy,c.name);
		}
	}
	copyLine(index,toCopy) {
		let o = { };
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			o[c.name] = Reflect.field(toCopy,c.name);
		}
		if(index == null) {
			this.sheet.lines.push(o);
		} else {
			let _g = 0;
			let _g1 = this.sheet.separators;
			while(_g < _g1.length) {
				let s = _g1[_g];
				++_g;
				if(s.index > index) {
					s.index++;
				}
			}
			this.sheet.lines.splice(index + 1,0,o);
			let _g2 = [];
			let _g3 = 0;
			let _g4 = this.sheet.lines.length;
			while(_g3 < _g4) {
				let i = _g3++;
				_g2.push(i <= index ? i : i + 1);
			}
			this.changeLineOrder(_g2);
		}
		return o;
	}
	getPath() {
		if(this.path == null) {
			return this.sheet.name;
		} else {
			return this.path;
		}
	}
	hasColumn(name,types) {
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.name == name) {
				if(types != null) {
					let _g = 0;
					while(_g < types.length) if(Type.enumEq(c.type,types[_g++])) {
						return true;
					}
					return false;
				}
				return true;
			}
		}
		return false;
	}
	moveLine(index,delta) {
		if(delta < 0) {
			let _g = 0;
			let _g1 = this.sheet.separators.length;
			while(_g < _g1) {
				let sep = this.sheet.separators[this.sheet.separators.length - 1 - _g++];
				if(sep.index == index) {
					sep.index++;
					return index;
				}
			}
			if(index <= 0) {
				return null;
			}
			let l = this.sheet.lines[index];
			this.sheet.lines.splice(index,1);
			this.sheet.lines.splice(index - 1,0,l);
			let _g2 = [];
			let _g3 = 0;
			let _g4 = this.sheet.lines.length;
			while(_g3 < _g4) _g2.push(_g3++);
			_g2[index] = index - 1;
			_g2[index - 1] = index;
			this.changeLineOrder(_g2);
			return index - 1;
		} else if(delta > 0) {
			let _g = 0;
			let _g1 = this.sheet.separators;
			while(_g < _g1.length) {
				let sep = _g1[_g];
				++_g;
				if(sep.index == index + 1) {
					sep.index--;
					return index;
				}
			}
			if(index < this.sheet.lines.length - 1) {
				let l = this.sheet.lines[index];
				this.sheet.lines.splice(index,1);
				this.sheet.lines.splice(index + 1,0,l);
				let _g = [];
				let _g1 = 0;
				let _g2 = this.sheet.lines.length;
				while(_g1 < _g2) _g.push(_g1++);
				_g[index] = index + 1;
				_g[index + 1] = index;
				this.changeLineOrder(_g);
				return index + 1;
			}
		}
		return null;
	}
	deleteLine(index) {
		let _g = [];
		let _g1 = 0;
		let _g2 = this.sheet.lines.length;
		while(_g1 < _g2) {
			let i = _g1++;
			if(i < index) {
				_g.push(i);
			} else {
				_g.push(i - 1);
			}
		}
		_g[index] = -1;
		this.changeLineOrder(_g);
		this.sheet.lines.splice(index,1);
		let _g3 = 0;
		let _g4 = this.sheet.separators.length;
		while(_g3 < _g4) {
			let s = this.sheet.separators[_g3++];
			if(s.index > index) {
				s.index--;
			}
		}
	}
	deleteColumn(cname) {
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.name == cname) {
				HxOverrides.remove(this.sheet.columns,c);
				let _g = 0;
				let _g1 = this.getLines();
				while(_g < _g1.length) Reflect.deleteField(_g1[_g++],c.name);
				if(this.sheet.props.displayColumn == c.name) {
					this.sheet.props.displayColumn = null;
					this.sync();
				}
				if(this.sheet.props.displayIcon == c.name) {
					this.sheet.props.displayIcon = null;
					this.sync();
				}
				if(c.type == cdb_ColumnType.TList || c.type == cdb_ColumnType.TProperties) {
					this.base.deleteSheet(this.base.getSheet(this.sheet.name + "@" + c.name));
				}
				return true;
			}
		}
		return false;
	}
	addColumn(c,index) {
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c2 = _g1[_g];
			++_g;
			if(c2.name == c.name) {
				return "Column already exists";
			} else if(c2.type == cdb_ColumnType.TId && c.type == cdb_ColumnType.TId) {
				return "Only one ID allowed";
			}
		}
		if(c.name == "index" && this.sheet.props.hasIndex) {
			return "Sheet already has an index";
		}
		if(c.name == "group" && this.sheet.props.hasGroup) {
			return "Sheet already has a group";
		}
		if(index == null) {
			this.sheet.columns.push(c);
		} else {
			this.sheet.columns.splice(index,0,c);
		}
		if(c.type == cdb_ColumnType.TList || c.type == cdb_ColumnType.TProperties) {
			this.base.createSubSheet(this,c);
		}
		let _g2 = 0;
		let _g3 = this.getLines();
		while(_g2 < _g3.length) {
			let i = _g3[_g2++];
			let def = this.base.getDefault(c,null,this);
			if(def != null) {
				i[c.name] = def;
			}
		}
		return null;
	}
	getDefaults() {
		let props = { };
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let d = this.base.getDefault(c,null,this);
			if(d != null) {
				props[c.name] = d;
			}
		}
		return props;
	}
	objToString(obj,esc) {
		if(esc == null) {
			esc = false;
		}
		if(obj == null) {
			return "null";
		}
		let fl = [];
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			let v = Reflect.field(obj,c.name);
			if(v == null) {
				continue;
			}
			fl.push(c.name + " : " + this.colToString(c,v,esc));
		}
		if(fl.length == 0) {
			return "{}";
		}
		return "{ " + fl.join(", ") + " }";
	}
	colToString(c,v,esc) {
		if(esc == null) {
			esc = false;
		}
		if(v == null) {
			return "null";
		}
		if(c.type._hx_index == 8) {
			let a = v;
			if(a.length == 0) {
				return "[]";
			}
			let s = this.base.getSheet(this.sheet.name + "@" + c.name);
			let _g = [];
			let _g1 = 0;
			while(_g1 < a.length) _g.push(s.objToString(a[_g1++],esc));
			return "[ " + _g.join(", ") + " ]";
		} else {
			return this.base.valToString(c.type,v,esc);
		}
	}
	changeLineOrder(remap) {
		let _g = 0;
		let _g1 = this.base.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = s.sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				let _g = c.type;
				if(_g._hx_index == 12) {
					if(_g.type == this.sheet.name) {
						let _g = 0;
						let _g1 = s.getLines();
						while(_g < _g1.length) {
							let obj = _g1[_g];
							++_g;
							let ldat = Reflect.field(obj,c.name);
							if(ldat == null || ldat == "") {
								continue;
							}
							let _g2 = [];
							let _g3 = 0;
							while(_g3 < 256) _g2.push(_g3++);
							let d = cdb_Layer.decode(ldat,_g2);
							let _g4 = 0;
							let _g5 = d.length;
							while(_g4 < _g5) {
								let i = _g4++;
								let r = remap[d[i]];
								if(r < 0) {
									r = 0;
								}
								d[i] = r;
							}
							ldat = cdb_Layer.encode(d,this.base.data.compress);
							obj[c.name] = ldat;
						}
					}
				}
			}
		}
	}
	getReferences(index) {
		let id = null;
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.type._hx_index == 0) {
				id = Reflect.field(this.sheet.lines[index],c.name);
				break;
			}
		}
		if(id == "" || id == null) {
			return null;
		}
		return this.getReferencesFromId(id);
	}
	getReferencesFromId(id) {
		let scopeObj = null;
		let depth = 0;
		let ourIdCol = this.idCol;
		if(ourIdCol == null) {
			let _g = 0;
			let _g1 = this.sheet.columns;
			while(_g < _g1.length) {
				let c = _g1[_g];
				++_g;
				if(c.type == cdb_ColumnType.TId) {
					ourIdCol = c;
					break;
				}
			}
		}
		if(ourIdCol != null && ourIdCol.scope != null && ourIdCol.scope >= 0) {
			let cur = this;
			let _g = 0;
			let _g1 = ourIdCol.scope - 1;
			while(_g < _g1) {
				++_g;
				cur = cur.parent.sheet;
			}
			let cur2 = cur;
			while(cur2 != null && cur2.parent != null) {
				cur2 = cur2.parent.sheet;
				++depth;
			}
			--depth;
			scopeObj = cur.parent.sheet.getLines()[cur.parent.line];
		}
		let results = [];
		let _g = 0;
		let _g1 = this.base.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			let _g2 = 0;
			let _g3 = s.sheet.columns;
			while(_g2 < _g3.length) {
				let c = _g3[_g2];
				++_g2;
				let _g = c.type;
				switch(_g._hx_index) {
				case 6:
					if(_g.sheet == this.sheet.name) {
						let sheets = [];
						let p = { s : s, c : c.name, id : null};
						while(true) {
							let _g = 0;
							let _g1 = p.s.sheet.columns;
							while(_g < _g1.length) {
								let c = _g1[_g];
								++_g;
								if(c.type._hx_index == 0) {
									p.id = c.name;
									break;
								}
							}
							sheets.unshift(p);
							let p2 = p.s.getParent();
							if(p2 == null) {
								break;
							}
							p = { s : p2.s, c : p2.c, id : null};
						}
						let _g = 0;
						let _g1 = s.getObjects();
						while(_g < _g1.length) {
							let o = _g1[_g];
							++_g;
							if(scopeObj != null && o.path[depth] != scopeObj) {
								continue;
							}
							if(Reflect.field(o.path[o.path.length - 1],c.name) == id) {
								results.push({ s : sheets, o : o});
							}
						}
					}
					break;
				case 9:
					break;
				default:
				}
			}
		}
		return results;
	}
	updateValue(c,index,old) {
		let _gthis = this;
		switch(c.type._hx_index) {
		case 0:
			this.sync();
			break;
		case 3:
			if(this.sheet.props.level != null && (c.name == "width" || c.name == "height")) {
				let obj = this.sheet.lines[index];
				let newW = Reflect.field(obj,"width");
				let newH = Reflect.field(obj,"height");
				let oldW = newW;
				let oldH = newH;
				if(c.name == "width") {
					oldW = old;
				} else {
					oldH = old;
				}
				let remapTileLayer = function(v) {
					if(v == null) {
						return null;
					}
					let odat = cdb_TileLayerData.decode(v.data);
					let ndat = [];
					if(odat[0] == 65535) {
						ndat = odat;
					} else {
						let pos = 0;
						let _g = 0;
						let _g1 = newH;
						while(_g < _g1) if(_g++ >= oldH) {
							let _g = 0;
							let _g1 = newW;
							while(_g < _g1) {
								++_g;
								ndat.push(0);
							}
						} else if(newW <= oldW) {
							let _g = 0;
							let _g1 = newW;
							while(_g < _g1) {
								++_g;
								ndat.push(odat[pos++]);
							}
							pos += oldW - newW;
						} else {
							let _g = 0;
							let _g1 = oldW;
							while(_g < _g1) {
								++_g;
								ndat.push(odat[pos++]);
							}
							let _g2 = oldW;
							let _g3 = newW;
							while(_g2 < _g3) {
								++_g2;
								ndat.push(0);
							}
						}
					}
					return { file : v.file, size : v.size, stride : v.stride, data : cdb_TileLayerData.encode(ndat,_gthis.base.data.compress)};
				};
				let _g = 0;
				let _g1 = this.sheet.columns;
				while(_g < _g1.length) {
					let c = _g1[_g];
					++_g;
					let v = Reflect.field(obj,c.name);
					if(v == null) {
						continue;
					}
					switch(c.type._hx_index) {
					case 8:
						let s = this.base.getSheet(this.sheet.name + "@" + c.name);
						if(s.hasColumn("x",[cdb_ColumnType.TInt,cdb_ColumnType.TFloat]) && s.hasColumn("y",[cdb_ColumnType.TInt,cdb_ColumnType.TFloat])) {
							let elts = Reflect.field(obj,c.name);
							let _g = 0;
							let _g1 = elts.slice();
							while(_g < _g1.length) {
								let e = _g1[_g];
								++_g;
								if(e.x >= newW || e.y >= newH) {
									HxOverrides.remove(elts,e);
								}
							}
						} else if(s.hasColumn("data",[cdb_ColumnType.TTileLayer])) {
							let a = v;
							let _g = 0;
							while(_g < a.length) {
								let o = a[_g];
								++_g;
								o.data = remapTileLayer(o.data);
							}
						}
						break;
					case 12:
						let v1 = v;
						let _g2 = [];
						let _g3 = 0;
						while(_g3 < 256) _g2.push(_g3++);
						let odat = cdb_Layer.decode(v1,_g2);
						let ndat = [];
						let _g4 = 0;
						let _g5 = newH;
						while(_g4 < _g5) {
							let y = _g4++;
							let _g = 0;
							let _g1 = newW;
							while(_g < _g1) {
								let x = _g++;
								ndat.push(y < oldH && x < oldW ? odat[x + y * oldW] : 0);
							}
						}
						v1 = cdb_Layer.encode(ndat,this.base.data.compress);
						obj[c.name] = v1;
						break;
					case 15:
						obj[c.name] = remapTileLayer(v);
						break;
					default:
					}
				}
			} else {
				if(this.sheet.props.displayColumn == c.name) {
					let obj = this.sheet.lines[index];
					let _g = 0;
					let _g1 = this.sheet.columns;
					while(_g < _g1.length) {
						let cid = _g1[_g];
						++_g;
						if(cid.type == cdb_ColumnType.TId) {
							let id = Reflect.field(obj,cid.name);
							if(id != null) {
								let disp = Reflect.field(obj,c.name);
								if(disp == null) {
									disp = "#" + id;
								}
								this.index.h[id].disp = disp;
							}
						}
					}
				}
				if(this.sheet.props.displayIcon == c.name) {
					let obj = this.sheet.lines[index];
					let _g = 0;
					let _g1 = this.sheet.columns;
					while(_g < _g1.length) {
						let cid = _g1[_g];
						++_g;
						if(cid.type == cdb_ColumnType.TId) {
							let id = Reflect.field(obj,cid.name);
							if(id != null && id != "") {
								this.index.h[id].ico = Reflect.field(obj,c.name);
							}
						}
					}
				}
			}
			break;
		default:
			if(this.sheet.props.displayColumn == c.name) {
				let obj = this.sheet.lines[index];
				let _g = 0;
				let _g1 = this.sheet.columns;
				while(_g < _g1.length) {
					let cid = _g1[_g];
					++_g;
					if(cid.type == cdb_ColumnType.TId) {
						let id = Reflect.field(obj,cid.name);
						if(id != null) {
							let disp = Reflect.field(obj,c.name);
							if(disp == null) {
								disp = "#" + id;
							}
							this.index.h[id].disp = disp;
						}
					}
				}
			}
			if(this.sheet.props.displayIcon == c.name) {
				let obj = this.sheet.lines[index];
				let _g = 0;
				let _g1 = this.sheet.columns;
				while(_g < _g1.length) {
					let cid = _g1[_g];
					++_g;
					if(cid.type == cdb_ColumnType.TId) {
						let id = Reflect.field(obj,cid.name);
						if(id != null && id != "") {
							this.index.h[id].ico = Reflect.field(obj,c.name);
						}
					}
				}
			}
		}
	}
	sortById(a,b) {
		if(a.disp > b.disp) {
			return 1;
		} else {
			return -1;
		}
	}
	rename(name) {
		let key = this.sheet.name;
		let _this = this.base.smap;
		if(Object.prototype.hasOwnProperty.call(_this.h,key)) {
			delete(_this.h[key]);
		}
		this.sheet.name = name;
		this.base.smap.h[name] = this;
	}
	sync() {
		if(this.parent != null) {
			throw haxe_Exception.thrown("assert");
		}
		this.index = new haxe_ds_StringMap();
		this.duplicateIds = new haxe_ds_StringMap();
		this.all = [];
		this.idCol = null;
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.type == cdb_ColumnType.TId) {
				let isLocal = c.scope != null;
				this.idCol = c;
				if(this.sheet.lines == null && this.sheet.props.dataFiles != null) {
					continue;
				}
				let _g = 0;
				let _g1 = this.getLines(c.scope);
				while(_g < _g1.length) {
					let l = _g1[_g];
					++_g;
					let obj = isLocal ? l.obj : l;
					let v = Reflect.field(obj,c.name);
					if(v == null || v == "") {
						continue;
					}
					let disp = v;
					if(isLocal) {
						if(l.id == null || l.id == "") {
							continue;
						}
						v = Std.string(l.id) + ":" + v;
					}
					let ico = null;
					if(this.sheet.props.displayColumn != null) {
						disp = Reflect.field(obj,this.sheet.props.displayColumn);
						if(disp == null || disp == "") {
							disp = "#" + v;
						}
					}
					if(this.sheet.props.displayIcon != null) {
						ico = Reflect.field(obj,this.sheet.props.displayIcon);
					}
					let o = { id : v, disp : disp, ico : ico, obj : obj};
					if(this.index.h[v] == null) {
						this.index.h[v] = o;
					} else {
						this.duplicateIds.h[v] = true;
					}
					this.all.push(o);
				}
				this.all.sort($bind(this,this.sortById));
				break;
			}
		}
		this.base.smap.h[this.sheet.name] = this;
	}
}
cdb_Sheet.__name__ = "cdb.Sheet";
Object.assign(cdb_Sheet.prototype, {
	__class__: cdb_Sheet
});
class cdb_SheetTypes {
}
cdb_SheetTypes.__name__ = "cdb.SheetTypes";
class cdb__$Types_ArrayIterator {
	constructor(a) {
		this.a = a;
		this.pos = 0;
	}
	hasNext() {
		return this.pos < this.a.length;
	}
	next() {
		return this.a[this.pos++];
	}
}
cdb__$Types_ArrayIterator.__name__ = "cdb._Types.ArrayIterator";
Object.assign(cdb__$Types_ArrayIterator.prototype, {
	__class__: cdb__$Types_ArrayIterator
});
class cdb__$Types_FlagsIterator {
	constructor(flags) {
		this.flags = flags;
		this.k = 0;
	}
	hasNext() {
		return this.flags >= 1 << this.k;
	}
	next() {
		while((this.flags & 1 << this.k) == 0) this.k++;
		return this.k++;
	}
}
cdb__$Types_FlagsIterator.__name__ = "cdb._Types.FlagsIterator";
Object.assign(cdb__$Types_FlagsIterator.prototype, {
	__class__: cdb__$Types_FlagsIterator
});
class cdb_ArrayRead {
	static _new(a) {
		return a;
	}
	static get_length(this1) {
		return this1.length;
	}
	static toIterable(this1) {
		return this1;
	}
	static iterator(this1) {
		return new cdb__$Types_ArrayIterator(this1);
	}
	static castArray(this1) {
		return this1;
	}
	static toArrayCopy(this1) {
		return this1.slice();
	}
	static getIndex(this1,v) {
		return this1[v];
	}
}
class cdb_Flags {
	static _new(x) {
		return x;
	}
	static has(this1,t) {
		return (this1 & 1 << t) != 0;
	}
	static set(this1,t) {
		this1 |= 1 << t;
	}
	static unset(this1,t) {
		this1 &= ~(1 << t);
	}
	static iterator(this1) {
		return new cdb__$Types_FlagsIterator(this1);
	}
	static toInt(this1) {
		return this1;
	}
}
class cdb_Layer {
	static _new(x) {
		return x;
	}
	static decode(this1,all) {
		let k = cdb_Lz4Reader.decodeString(this1);
		let _g = [];
		let _g1 = 0;
		let _g2 = k.length;
		while(_g1 < _g2) _g.push(all[k.b[_g1++]]);
		return _g;
	}
	static encode(a,compress) {
		let b = new haxe_io_Bytes(new ArrayBuffer(a.length));
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			b.b[i] = a[i];
		}
		return cdb_Lz4Reader.encodeBytes(b,compress);
	}
}
class cdb_TileLayerData {
	static _new(v) {
		return v;
	}
	static decode(this1) {
		let k = cdb_Lz4Reader.decodeString(this1);
		let _g = [];
		let _g1 = 0;
		let _g2 = k.length >> 1;
		while(_g1 < _g2) {
			let i = _g1++;
			_g.push(k.b[i << 1] | k.b[(i << 1) + 1] << 8);
		}
		return _g;
	}
	static encode(a,compress) {
		let b = new haxe_io_Bytes(new ArrayBuffer(a.length * 2));
		let _g = 0;
		let _g1 = a.length;
		while(_g < _g1) {
			let i = _g++;
			let v = a[i];
			b.b[i << 1] = v & 255;
			b.b[(i << 1) + 1] = v >> 8 & 255;
		}
		return cdb_TileLayerData._new(cdb_Lz4Reader.encodeBytes(b,compress));
	}
}
class cdb_LevelPropsAccess {
	static get_tileSize(this1) {
		return this1.tileSize;
	}
	static getTileset(this1,i,name) {
		return Reflect.field(i.sheet.props.level.tileSets,name);
	}
	static getLayer(this1,name) {
		if(this1 == null || this1.layers == null) {
			return null;
		}
		let _g = 0;
		let _g1 = this1.layers;
		while(_g < _g1.length) {
			let l = _g1[_g];
			++_g;
			if(l.l == name) {
				return l.p;
			}
		}
		return null;
	}
}
class cdb_Index {
	constructor(data,name) {
		this.name = name;
		this.initSheet(data);
		if(this.sheet == null) {
			throw haxe_Exception.thrown("'" + name + "' not found in CDB data");
		}
	}
	initSheet(data) {
		let _g = 0;
		let _g1 = data.sheets;
		while(_g < _g1.length) {
			let s = _g1[_g];
			++_g;
			if(s.name == this.name) {
				this.all = s.lines;
				this.sheet = s;
				if(s.props.hasIndex) {
					let _g = 0;
					let _g1 = this.all.length;
					while(_g < _g1) {
						let i = _g++;
						this.all[i].index = i;
					}
				}
				if(s.props.hasGroup) {
					let gid = -1;
					let sindex = 0;
					while(true) {
						let s1 = s.separators[sindex];
						if(s1 == null || s1.index != 0) {
							break;
						}
						++sindex;
						if(s1.title != null) {
							++gid;
						}
					}
					if(gid < 0) {
						++gid;
					}
					let _g = 0;
					let _g1 = this.all.length;
					while(_g < _g1) {
						let i = _g++;
						while(true) {
							let s1 = s.separators[sindex];
							if(s1 == null || s1.index != i) {
								break;
							}
							if(s1.title != null) {
								++gid;
							}
							++sindex;
						}
						this.all[i].group = gid;
					}
				}
				break;
			}
		}
	}
}
cdb_Index.__name__ = "cdb.Index";
Object.assign(cdb_Index.prototype, {
	__class__: cdb_Index
});
class cdb_IndexId extends cdb_Index {
	constructor(data,name) {
		super(data,name);
	}
	initSheet(data) {
		super.initSheet(data);
		this.byId = new haxe_ds_StringMap();
		this.byIndex = [];
		let _g = 0;
		let _g1 = this.sheet.columns;
		while(_g < _g1.length) {
			let c = _g1[_g];
			++_g;
			if(c.type._hx_index == 0) {
				let cname = c.name;
				let _g = 0;
				let _g1 = this.sheet.lines;
				while(_g < _g1.length) {
					let a = _g1[_g];
					++_g;
					let id = Reflect.field(a,cname);
					if(id != null && id != "") {
						this.byId.h[id] = a;
						this.byIndex.push(a);
					}
				}
				break;
			}
		}
	}
	reload(data) {
		let oldId = this.byId;
		this.initSheet(data);
		let id_keys = Object.keys(this.byId.h);
		let id_length = id_keys.length;
		let id_current = 0;
		while(id_current < id_length) {
			let id = id_keys[id_current++];
			let oldObj = oldId.h[id];
			if(oldObj == null) {
				continue;
			}
			let newObj = this.byId.h[id];
			let fields = Reflect.fields(oldObj);
			let _g = 0;
			let _g1 = Reflect.fields(newObj);
			while(_g < _g1.length) {
				let f = _g1[_g];
				++_g;
				oldObj[f] = Reflect.field(newObj,f);
				HxOverrides.remove(fields,f);
			}
			let _g2 = 0;
			while(_g2 < fields.length) Reflect.deleteField(oldObj,fields[_g2++]);
			let idx = this.byIndex.indexOf(newObj);
			if(idx >= 0) {
				this.byIndex[idx] = oldObj;
			}
			this.sheet.lines[this.sheet.lines.indexOf(newObj)] = oldObj;
			this.byId.h[id] = oldObj;
		}
	}
	get(k) {
		return this.byId.h[k];
	}
	resolve(id,opt,approximate) {
		if(id == null) {
			return null;
		}
		let v = this.byId.h[id];
		if(v == null && approximate) {
			id = id.toLowerCase();
			let best = 1000;
			let h = this.byId.h;
			let _g_keys = Object.keys(h);
			let _g_length = _g_keys.length;
			let _g_current = 0;
			while(_g_current < _g_length) {
				let key = _g_keys[_g_current++];
				let _g_value = h[key];
				if(key.toLowerCase().startsWith(id) && key.length < best) {
					v = _g_value;
					best = key.length;
				}
			}
		}
		if(v == null && !opt) {
			throw haxe_Exception.thrown("Missing " + this.name + "." + id);
		} else {
			return v;
		}
	}
}
cdb_IndexId.__name__ = "cdb.IndexId";
Object.assign(cdb_IndexId.prototype, {
	__class__: cdb_IndexId
});
class haxe_Exception extends Error {
	constructor(message,previous,native) {
		super(message);
		this.message = message;
		this.__previousException = previous;
		this.__nativeException = native != null ? native : this;
	}
	unwrap() {
		return this.__nativeException;
	}
	get_native() {
		return this.__nativeException;
	}
	static caught(value) {
		if(((value) instanceof haxe_Exception)) {
			return value;
		} else if(((value) instanceof Error)) {
			return new haxe_Exception(value.message,null,value);
		} else {
			return new haxe_ValueException(value,null,value);
		}
	}
	static thrown(value) {
		if(((value) instanceof haxe_Exception)) {
			return value.get_native();
		} else if(((value) instanceof Error)) {
			return value;
		} else {
			let e = new haxe_ValueException(value);
			return e;
		}
	}
}
haxe_Exception.__name__ = "haxe.Exception";
Object.assign(haxe_Exception.prototype, {
	__class__: haxe_Exception
});
class haxe_ValueException extends haxe_Exception {
	constructor(value,previous,native) {
		super(String(value),previous,native);
		this.value = value;
	}
	unwrap() {
		return this.value;
	}
}
haxe_ValueException.__name__ = "haxe.ValueException";
Object.assign(haxe_ValueException.prototype, {
	__class__: haxe_ValueException
});
class haxe_io_Bytes {
	constructor(data) {
		this.length = data.byteLength;
		this.b = new Uint8Array(data);
		this.b.bufferValue = data;
		data.hxBytes = this;
		data.bytes = this.b;
	}
	blit(pos,src,srcpos,len) {
		if(pos < 0 || srcpos < 0 || len < 0 || pos + len > this.length || srcpos + len > src.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(srcpos == 0 && len == src.b.byteLength) {
			this.b.set(src.b,pos);
		} else {
			this.b.set(src.b.subarray(srcpos,srcpos + len),pos);
		}
	}
	sub(pos,len) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		return new haxe_io_Bytes(this.b.buffer.slice(pos + this.b.byteOffset,pos + this.b.byteOffset + len));
	}
	getString(pos,len,encoding) {
		if(pos < 0 || len < 0 || pos + len > this.length) {
			throw haxe_Exception.thrown(haxe_io_Error.OutsideBounds);
		}
		if(encoding == null) {
			encoding = haxe_io_Encoding.UTF8;
		}
		let s = "";
		let b = this.b;
		let i = pos;
		let max = pos + len;
		switch(encoding._hx_index) {
		case 0:
			while(i < max) {
				let c = b[i++];
				if(c < 128) {
					if(c == 0) {
						break;
					}
					s += String.fromCodePoint(c);
				} else if(c < 224) {
					let code = (c & 63) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else if(c < 240) {
					let code = (c & 31) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(code);
				} else {
					let u = (c & 15) << 18 | (b[i++] & 127) << 12 | (b[i++] & 127) << 6 | b[i++] & 127;
					s += String.fromCodePoint(u);
				}
			}
			break;
		case 1:
			while(i < max) {
				let c = b[i++] | b[i++] << 8;
				s += String.fromCodePoint(c);
			}
			break;
		}
		return s;
	}
	toString() {
		return this.getString(0,this.length);
	}
	static ofString(s,encoding) {
		if(encoding == haxe_io_Encoding.RawNative) {
			let buf = new Uint8Array(s.length << 1);
			let _g = 0;
			let _g1 = s.length;
			while(_g < _g1) {
				let i = _g++;
				let c = s.charCodeAt(i);
				buf[i << 1] = c & 255;
				buf[i << 1 | 1] = c >> 8;
			}
			return new haxe_io_Bytes(buf.buffer);
		}
		let a = [];
		let i = 0;
		while(i < s.length) {
			let c = s.charCodeAt(i++);
			if(55296 <= c && c <= 56319) {
				c = c - 55232 << 10 | s.charCodeAt(i++) & 1023;
			}
			if(c <= 127) {
				a.push(c);
			} else if(c <= 2047) {
				a.push(192 | c >> 6);
				a.push(128 | c & 63);
			} else if(c <= 65535) {
				a.push(224 | c >> 12);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			} else {
				a.push(240 | c >> 18);
				a.push(128 | c >> 12 & 63);
				a.push(128 | c >> 6 & 63);
				a.push(128 | c & 63);
			}
		}
		return new haxe_io_Bytes(new Uint8Array(a).buffer);
	}
}
haxe_io_Bytes.__name__ = "haxe.io.Bytes";
Object.assign(haxe_io_Bytes.prototype, {
	__class__: haxe_io_Bytes
});
var haxe_io_Encoding = $hxEnums["haxe.io.Encoding"] = { __ename__:true,__constructs__:null
	,UTF8: {_hx_name:"UTF8",_hx_index:0,__enum__:"haxe.io.Encoding",toString:$estr}
	,RawNative: {_hx_name:"RawNative",_hx_index:1,__enum__:"haxe.io.Encoding",toString:$estr}
};
haxe_io_Encoding.__constructs__ = [haxe_io_Encoding.UTF8,haxe_io_Encoding.RawNative];
class haxe_crypto_Base64 {
	static encode(bytes,complement) {
		if(complement == null) {
			complement = true;
		}
		let str = new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).encodeBytes(bytes).toString();
		if(complement) {
			switch(bytes.length % 3) {
			case 1:
				str += "==";
				break;
			case 2:
				str += "=";
				break;
			default:
			}
		}
		return str;
	}
	static decode(str,complement) {
		if(complement == null) {
			complement = true;
		}
		if(complement) {
			while(HxOverrides.cca(str,str.length - 1) == 61) str = HxOverrides.substr(str,0,-1);
		}
		return new haxe_crypto_BaseCode(haxe_crypto_Base64.BYTES).decodeBytes(haxe_io_Bytes.ofString(str));
	}
}
haxe_crypto_Base64.__name__ = "haxe.crypto.Base64";
class haxe_crypto_BaseCode {
	constructor(base) {
		let len = base.length;
		let nbits = 1;
		while(len > 1 << nbits) ++nbits;
		if(nbits > 8 || len != 1 << nbits) {
			throw haxe_Exception.thrown("BaseCode : base length must be a power of two.");
		}
		this.base = base;
		this.nbits = nbits;
	}
	encodeBytes(b) {
		let nbits = this.nbits;
		let base = this.base;
		let size = b.length * 8 / nbits | 0;
		let out = new haxe_io_Bytes(new ArrayBuffer(size + (b.length * 8 % nbits == 0 ? 0 : 1)));
		let buf = 0;
		let curbits = 0;
		let mask = (1 << nbits) - 1;
		let pin = 0;
		let pout = 0;
		while(pout < size) {
			while(curbits < nbits) {
				curbits += 8;
				buf <<= 8;
				buf |= b.b[pin++];
			}
			curbits -= nbits;
			out.b[pout++] = base.b[buf >> curbits & mask];
		}
		if(curbits > 0) {
			out.b[pout++] = base.b[buf << nbits - curbits & mask];
		}
		return out;
	}
	initTable() {
		let tbl = [];
		let _g = 0;
		while(_g < 256) tbl[_g++] = -1;
		let _g1 = 0;
		let _g2 = this.base.length;
		while(_g1 < _g2) {
			let i = _g1++;
			tbl[this.base.b[i]] = i;
		}
		this.tbl = tbl;
	}
	decodeBytes(b) {
		let nbits = this.nbits;
		if(this.tbl == null) {
			this.initTable();
		}
		let tbl = this.tbl;
		let size = b.length * nbits >> 3;
		let out = new haxe_io_Bytes(new ArrayBuffer(size));
		let buf = 0;
		let curbits = 0;
		let pin = 0;
		let pout = 0;
		while(pout < size) {
			while(curbits < 8) {
				curbits += nbits;
				buf <<= nbits;
				let i = tbl[b.b[pin++]];
				if(i == -1) {
					throw haxe_Exception.thrown("BaseCode : invalid encoded char");
				}
				buf |= i;
			}
			curbits -= 8;
			out.b[pout++] = buf >> curbits & 255;
		}
		return out;
	}
}
haxe_crypto_BaseCode.__name__ = "haxe.crypto.BaseCode";
Object.assign(haxe_crypto_BaseCode.prototype, {
	__class__: haxe_crypto_BaseCode
});
class haxe_ds_IntMap {
	constructor() {
		this.h = { };
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		let a = [];
		for( var key in this.h ) if(this.h.hasOwnProperty(key)) a.push(+key);
		return new haxe_iterators_ArrayIterator(a);
	}
	iterator() {
		return { ref : this.h, it : this.keys(), hasNext : function() {
			return this.it.hasNext();
		}, next : function() {
			let i = this.it.next();
			return this.ref[i];
		}};
	}
	keyValueIterator() {
		return new haxe_iterators_MapKeyValueIterator(this);
	}
}
haxe_ds_IntMap.__name__ = "haxe.ds.IntMap";
Object.assign(haxe_ds_IntMap.prototype, {
	__class__: haxe_ds_IntMap
});
class haxe_ds_List {
	constructor() {
		this.length = 0;
	}
	add(item) {
		let x = new haxe_ds__$List_ListNode(item,null);
		if(this.h == null) {
			this.h = x;
		} else {
			this.q.next = x;
		}
		this.q = x;
		this.length++;
	}
	remove(v) {
		let prev = null;
		let l = this.h;
		while(l != null) {
			if(l.item == v) {
				if(prev == null) {
					this.h = l.next;
				} else {
					prev.next = l.next;
				}
				if(this.q == l) {
					this.q = prev;
				}
				this.length--;
				return true;
			}
			prev = l;
			l = l.next;
		}
		return false;
	}
	iterator() {
		return new haxe_ds__$List_ListIterator(this.h);
	}
}
haxe_ds_List.__name__ = "haxe.ds.List";
Object.assign(haxe_ds_List.prototype, {
	__class__: haxe_ds_List
});
class haxe_ds__$List_ListNode {
	constructor(item,next) {
		this.item = item;
		this.next = next;
	}
}
haxe_ds__$List_ListNode.__name__ = "haxe.ds._List.ListNode";
Object.assign(haxe_ds__$List_ListNode.prototype, {
	__class__: haxe_ds__$List_ListNode
});
class haxe_ds__$List_ListIterator {
	constructor(head) {
		this.head = head;
	}
	hasNext() {
		return this.head != null;
	}
	next() {
		let val = this.head.item;
		this.head = this.head.next;
		return val;
	}
}
haxe_ds__$List_ListIterator.__name__ = "haxe.ds._List.ListIterator";
Object.assign(haxe_ds__$List_ListIterator.prototype, {
	__class__: haxe_ds__$List_ListIterator
});
class haxe_ds_StringMap {
	constructor() {
		this.h = Object.create(null);
	}
	get(key) {
		return this.h[key];
	}
	keys() {
		return new haxe_ds__$StringMap_StringMapKeyIterator(this.h);
	}
	keyValueIterator() {
		return new haxe_ds__$StringMap_StringMapKeyValueIterator(this.h);
	}
}
haxe_ds_StringMap.__name__ = "haxe.ds.StringMap";
Object.assign(haxe_ds_StringMap.prototype, {
	__class__: haxe_ds_StringMap
});
class haxe_ds__$StringMap_StringMapKeyIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		return this.keys[this.current++];
	}
}
haxe_ds__$StringMap_StringMapKeyIterator.__name__ = "haxe.ds._StringMap.StringMapKeyIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyIterator
});
class haxe_ds__$StringMap_StringMapKeyValueIterator {
	constructor(h) {
		this.h = h;
		this.keys = Object.keys(h);
		this.length = this.keys.length;
		this.current = 0;
	}
	hasNext() {
		return this.current < this.length;
	}
	next() {
		let key = this.keys[this.current++];
		return { key : key, value : this.h[key]};
	}
}
haxe_ds__$StringMap_StringMapKeyValueIterator.__name__ = "haxe.ds._StringMap.StringMapKeyValueIterator";
Object.assign(haxe_ds__$StringMap_StringMapKeyValueIterator.prototype, {
	__class__: haxe_ds__$StringMap_StringMapKeyValueIterator
});
var haxe_io_Error = $hxEnums["haxe.io.Error"] = { __ename__:true,__constructs__:null
	,Blocked: {_hx_name:"Blocked",_hx_index:0,__enum__:"haxe.io.Error",toString:$estr}
	,Overflow: {_hx_name:"Overflow",_hx_index:1,__enum__:"haxe.io.Error",toString:$estr}
	,OutsideBounds: {_hx_name:"OutsideBounds",_hx_index:2,__enum__:"haxe.io.Error",toString:$estr}
	,Custom: ($_=function(e) { return {_hx_index:3,e:e,__enum__:"haxe.io.Error",toString:$estr}; },$_._hx_name="Custom",$_.__params__ = ["e"],$_)
};
haxe_io_Error.__constructs__ = [haxe_io_Error.Blocked,haxe_io_Error.Overflow,haxe_io_Error.OutsideBounds,haxe_io_Error.Custom];
class haxe_iterators_ArrayIterator {
	constructor(array) {
		this.current = 0;
		this.array = array;
	}
	hasNext() {
		return this.current < this.array.length;
	}
	next() {
		return this.array[this.current++];
	}
}
haxe_iterators_ArrayIterator.__name__ = "haxe.iterators.ArrayIterator";
Object.assign(haxe_iterators_ArrayIterator.prototype, {
	__class__: haxe_iterators_ArrayIterator
});
class haxe_iterators_MapKeyValueIterator {
	constructor(map) {
		this.map = map;
		this.keys = map.keys();
	}
	hasNext() {
		return this.keys.hasNext();
	}
	next() {
		let key = this.keys.next();
		return { value : this.map.get(key), key : key};
	}
}
haxe_iterators_MapKeyValueIterator.__name__ = "haxe.iterators.MapKeyValueIterator";
Object.assign(haxe_iterators_MapKeyValueIterator.prototype, {
	__class__: haxe_iterators_MapKeyValueIterator
});
var hxsqlparser_SqlCommand = $hxEnums["hxsqlparser.SqlCommand"] = { __ename__:true,__constructs__:null
	,Select: ($_=function(fields,fromClause,whereClause) { return {_hx_index:0,fields:fields,fromClause:fromClause,whereClause:whereClause,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="Select",$_.__params__ = ["fields","fromClause","whereClause"],$_)
	,Update: ($_=function(table,setFields,whereClause) { return {_hx_index:1,table:table,setFields:setFields,whereClause:whereClause,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="Update",$_.__params__ = ["table","setFields","whereClause"],$_)
	,Insert: ($_=function(table,fieldNames,insertValue) { return {_hx_index:2,table:table,fieldNames:fieldNames,insertValue:insertValue,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="Insert",$_.__params__ = ["table","fieldNames","insertValue"],$_)
	,Delete: ($_=function(table,whereClause) { return {_hx_index:3,table:table,whereClause:whereClause,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="Delete",$_.__params__ = ["table","whereClause"],$_)
	,CreateTable: ($_=function(table,fields) { return {_hx_index:4,table:table,fields:fields,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="CreateTable",$_.__params__ = ["table","fields"],$_)
	,AlterTable: ($_=function(table,alters) { return {_hx_index:5,table:table,alters:alters,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="AlterTable",$_.__params__ = ["table","alters"],$_)
	,DropTable: ($_=function(table) { return {_hx_index:6,table:table,__enum__:"hxsqlparser.SqlCommand",toString:$estr}; },$_._hx_name="DropTable",$_.__params__ = ["table"],$_)
};
hxsqlparser_SqlCommand.__constructs__ = [hxsqlparser_SqlCommand.Select,hxsqlparser_SqlCommand.Update,hxsqlparser_SqlCommand.Insert,hxsqlparser_SqlCommand.Delete,hxsqlparser_SqlCommand.CreateTable,hxsqlparser_SqlCommand.AlterTable,hxsqlparser_SqlCommand.DropTable];
var hxsqlparser_FromClause = $hxEnums["hxsqlparser.FromClause"] = { __ename__:true,__constructs__:null
	,Table: ($_=function(table) { return {_hx_index:0,table:table,__enum__:"hxsqlparser.FromClause",toString:$estr}; },$_._hx_name="Table",$_.__params__ = ["table"],$_)
	,Query: ($_=function(command) { return {_hx_index:1,command:command,__enum__:"hxsqlparser.FromClause",toString:$estr}; },$_._hx_name="Query",$_.__params__ = ["command"],$_)
	,InnerJoin: ($_=function(left,right,on) { return {_hx_index:2,left:left,right:right,on:on,__enum__:"hxsqlparser.FromClause",toString:$estr}; },$_._hx_name="InnerJoin",$_.__params__ = ["left","right","on"],$_)
	,OuterJoin: ($_=function(left,right,on) { return {_hx_index:3,left:left,right:right,on:on,__enum__:"hxsqlparser.FromClause",toString:$estr}; },$_._hx_name="OuterJoin",$_.__params__ = ["left","right","on"],$_)
};
hxsqlparser_FromClause.__constructs__ = [hxsqlparser_FromClause.Table,hxsqlparser_FromClause.Query,hxsqlparser_FromClause.InnerJoin,hxsqlparser_FromClause.OuterJoin];
var hxsqlparser_SqlValue = $hxEnums["hxsqlparser.SqlValue"] = { __ename__:true,__constructs__:null
	,Value: ($_=function(kind,value) { return {_hx_index:0,kind:kind,value:value,__enum__:"hxsqlparser.SqlValue",toString:$estr}; },$_._hx_name="Value",$_.__params__ = ["kind","value"],$_)
	,Query: ($_=function(command) { return {_hx_index:1,command:command,__enum__:"hxsqlparser.SqlValue",toString:$estr}; },$_._hx_name="Query",$_.__params__ = ["command"],$_)
};
hxsqlparser_SqlValue.__constructs__ = [hxsqlparser_SqlValue.Value,hxsqlparser_SqlValue.Query];
var hxsqlparser_InsertValue = $hxEnums["hxsqlparser.InsertValue"] = { __ename__:true,__constructs__:null
	,Row: ($_=function(fields) { return {_hx_index:0,fields:fields,__enum__:"hxsqlparser.InsertValue",toString:$estr}; },$_._hx_name="Row",$_.__params__ = ["fields"],$_)
	,Multiple: ($_=function(rows) { return {_hx_index:1,rows:rows,__enum__:"hxsqlparser.InsertValue",toString:$estr}; },$_._hx_name="Multiple",$_.__params__ = ["rows"],$_)
	,Query: ($_=function(command) { return {_hx_index:2,command:command,__enum__:"hxsqlparser.InsertValue",toString:$estr}; },$_._hx_name="Query",$_.__params__ = ["command"],$_)
};
hxsqlparser_InsertValue.__constructs__ = [hxsqlparser_InsertValue.Row,hxsqlparser_InsertValue.Multiple,hxsqlparser_InsertValue.Query];
var hxsqlparser_Condition = $hxEnums["hxsqlparser.Condition"] = { __ename__:true,__constructs__:null
	,Relational: ($_=function(field,binop,value) { return {_hx_index:0,field:field,binop:binop,value:value,__enum__:"hxsqlparser.Condition",toString:$estr}; },$_._hx_name="Relational",$_.__params__ = ["field","binop","value"],$_)
	,IsNull: ($_=function(field) { return {_hx_index:1,field:field,__enum__:"hxsqlparser.Condition",toString:$estr}; },$_._hx_name="IsNull",$_.__params__ = ["field"],$_)
	,IsNotNull: ($_=function(field) { return {_hx_index:2,field:field,__enum__:"hxsqlparser.Condition",toString:$estr}; },$_._hx_name="IsNotNull",$_.__params__ = ["field"],$_)
	,And: ($_=function(left,right) { return {_hx_index:3,left:left,right:right,__enum__:"hxsqlparser.Condition",toString:$estr}; },$_._hx_name="And",$_.__params__ = ["left","right"],$_)
	,Or: ($_=function(left,right) { return {_hx_index:4,left:left,right:right,__enum__:"hxsqlparser.Condition",toString:$estr}; },$_._hx_name="Or",$_.__params__ = ["left","right"],$_)
};
hxsqlparser_Condition.__constructs__ = [hxsqlparser_Condition.Relational,hxsqlparser_Condition.IsNull,hxsqlparser_Condition.IsNotNull,hxsqlparser_Condition.And,hxsqlparser_Condition.Or];
var hxsqlparser_Binop = $hxEnums["hxsqlparser.Binop"] = { __ename__:true,__constructs__:null
	,Eq: {_hx_name:"Eq",_hx_index:0,__enum__:"hxsqlparser.Binop",toString:$estr}
	,Neq: {_hx_name:"Neq",_hx_index:1,__enum__:"hxsqlparser.Binop",toString:$estr}
	,Gt: {_hx_name:"Gt",_hx_index:2,__enum__:"hxsqlparser.Binop",toString:$estr}
	,GtEq: {_hx_name:"GtEq",_hx_index:3,__enum__:"hxsqlparser.Binop",toString:$estr}
	,Lt: {_hx_name:"Lt",_hx_index:4,__enum__:"hxsqlparser.Binop",toString:$estr}
	,LtEq: {_hx_name:"LtEq",_hx_index:5,__enum__:"hxsqlparser.Binop",toString:$estr}
	,Like: {_hx_name:"Like",_hx_index:6,__enum__:"hxsqlparser.Binop",toString:$estr}
	,NotLike: {_hx_name:"NotLike",_hx_index:7,__enum__:"hxsqlparser.Binop",toString:$estr}
	,In: {_hx_name:"In",_hx_index:8,__enum__:"hxsqlparser.Binop",toString:$estr}
	,NotIn: {_hx_name:"NotIn",_hx_index:9,__enum__:"hxsqlparser.Binop",toString:$estr}
};
hxsqlparser_Binop.__constructs__ = [hxsqlparser_Binop.Eq,hxsqlparser_Binop.Neq,hxsqlparser_Binop.Gt,hxsqlparser_Binop.GtEq,hxsqlparser_Binop.Lt,hxsqlparser_Binop.LtEq,hxsqlparser_Binop.Like,hxsqlparser_Binop.NotLike,hxsqlparser_Binop.In,hxsqlparser_Binop.NotIn];
var hxsqlparser_SqlType = $hxEnums["hxsqlparser.SqlType"] = { __ename__:true,__constructs__:null
	,INT: {_hx_name:"INT",_hx_index:0,__enum__:"hxsqlparser.SqlType",toString:$estr}
	,STRING: {_hx_name:"STRING",_hx_index:1,__enum__:"hxsqlparser.SqlType",toString:$estr}
	,DATE: {_hx_name:"DATE",_hx_index:2,__enum__:"hxsqlparser.SqlType",toString:$estr}
	,BOOLEAN: {_hx_name:"BOOLEAN",_hx_index:3,__enum__:"hxsqlparser.SqlType",toString:$estr}
	,FLOAT: {_hx_name:"FLOAT",_hx_index:4,__enum__:"hxsqlparser.SqlType",toString:$estr}
	,OTHER: ($_=function(name) { return {_hx_index:5,name:name,__enum__:"hxsqlparser.SqlType",toString:$estr}; },$_._hx_name="OTHER",$_.__params__ = ["name"],$_)
	,UNKNOWN: {_hx_name:"UNKNOWN",_hx_index:6,__enum__:"hxsqlparser.SqlType",toString:$estr}
};
hxsqlparser_SqlType.__constructs__ = [hxsqlparser_SqlType.INT,hxsqlparser_SqlType.STRING,hxsqlparser_SqlType.DATE,hxsqlparser_SqlType.BOOLEAN,hxsqlparser_SqlType.FLOAT,hxsqlparser_SqlType.OTHER,hxsqlparser_SqlType.UNKNOWN];
var hxsqlparser_AlterCommand = $hxEnums["hxsqlparser.AlterCommand"] = { __ename__:true,__constructs__:null
	,RenameTo: ($_=function(name) { return {_hx_index:0,name:name,__enum__:"hxsqlparser.AlterCommand",toString:$estr}; },$_._hx_name="RenameTo",$_.__params__ = ["name"],$_)
	,AddColumn: ($_=function(name,type) { return {_hx_index:1,name:name,type:type,__enum__:"hxsqlparser.AlterCommand",toString:$estr}; },$_._hx_name="AddColumn",$_.__params__ = ["name","type"],$_)
	,DropColumn: ($_=function(name) { return {_hx_index:2,name:name,__enum__:"hxsqlparser.AlterCommand",toString:$estr}; },$_._hx_name="DropColumn",$_.__params__ = ["name"],$_)
	,ModifyColumn: ($_=function(name,type) { return {_hx_index:3,name:name,type:type,__enum__:"hxsqlparser.AlterCommand",toString:$estr}; },$_._hx_name="ModifyColumn",$_.__params__ = ["name","type"],$_)
	,RenameColumn: ($_=function(oldName,newName) { return {_hx_index:4,oldName:oldName,newName:newName,__enum__:"hxsqlparser.AlterCommand",toString:$estr}; },$_._hx_name="RenameColumn",$_.__params__ = ["oldName","newName"],$_)
};
hxsqlparser_AlterCommand.__constructs__ = [hxsqlparser_AlterCommand.RenameTo,hxsqlparser_AlterCommand.AddColumn,hxsqlparser_AlterCommand.DropColumn,hxsqlparser_AlterCommand.ModifyColumn,hxsqlparser_AlterCommand.RenameColumn];
class hxsqlparser_SqlCommandParse {
	constructor() {
	}
	parse(args) {
		this.tokens = args;
		this.pos = 0;
		let commands = [];
		while(this.pos < this.tokens.length) commands.push(this.parseCommand());
		return commands;
	}
	parseCommand() {
		let token = this.nextToken();
		switch(token._hx_index) {
		case 3:
			switch(token.s) {
			case "ALTER":
				return hxsqlparser_branches_Alter.parse(this);
			case "CREATE":
				return hxsqlparser_branches_Create.parse(this);
			case "DELETE":
				return hxsqlparser_branches_Delete.parse(this);
			case "DROP":
				return hxsqlparser_branches_Drop.parse(this);
			case "INSERT":
				return hxsqlparser_branches_Insert.parse(this);
			case "SELECT":
				return hxsqlparser_branches_Select.parse(this);
			case "UPDATE":
				return hxsqlparser_branches_Update.parse(this);
			default:
				throw haxe_Exception.thrown("Unexpected token: " + Std.string(token));
			}
			break;
		case 6:
			throw haxe_Exception.thrown("Unexpected end of input");
		default:
			throw haxe_Exception.thrown("Unexpected token: " + Std.string(token));
		}
	}
	getSqlValue(field) {
		switch(field._hx_index) {
		case 0:
			return hxsqlparser_SqlValue.Value(hxsqlparser_SqlType.INT,field.v);
		case 1:
			return hxsqlparser_SqlValue.Value(hxsqlparser_SqlType.FLOAT,field.v);
		case 2:
			return hxsqlparser_SqlValue.Value(hxsqlparser_SqlType.STRING,field.v);
		default:
		}
		return hxsqlparser_SqlValue.Value(hxsqlparser_SqlType.UNKNOWN,Std.string(field));
	}
	extractValue(t) {
		switch(t._hx_index) {
		case 0:
			return t.v;
		case 1:
			return t.v;
		case 3:
			return t.s;
		case 4:
			return t.s;
		case 10:
			switch(t.op._hx_index) {
			case 0:
				return hxsqlparser_Binop.Eq;
			case 1:
				return hxsqlparser_Binop.Lt;
			case 2:
				return hxsqlparser_Binop.Gt;
			case 3:
				return hxsqlparser_Binop.LtEq;
			case 4:
				return hxsqlparser_Binop.GtEq;
			case 5:
				return hxsqlparser_Binop.Neq;
			}
			break;
		default:
			return t;
		}
	}
	peekToken() {
		return this.tokens[this.pos];
	}
	nextToken() {
		return this.tokens[this.pos++];
	}
	parseSqlType(type) {
		switch(type) {
		case "BOOLEAN":
			return hxsqlparser_SqlType.BOOLEAN;
		case "DATE":
			return hxsqlparser_SqlType.DATE;
		case "FLOAT":
			return hxsqlparser_SqlType.FLOAT;
		case "INT":
			return hxsqlparser_SqlType.INT;
		case "STRING":
			return hxsqlparser_SqlType.STRING;
		default:
			return hxsqlparser_SqlType.OTHER(type);
		}
	}
}
hxsqlparser_SqlCommandParse.__name__ = "hxsqlparser.SqlCommandParse";
Object.assign(hxsqlparser_SqlCommandParse.prototype, {
	__class__: hxsqlparser_SqlCommandParse
});
var hxsqlparser_Token = $hxEnums["hxsqlparser.Token"] = { __ename__:true,__constructs__:null
	,CInt: ($_=function(v) { return {_hx_index:0,v:v,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="CInt",$_.__params__ = ["v"],$_)
	,CFloat: ($_=function(v) { return {_hx_index:1,v:v,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="CFloat",$_.__params__ = ["v"],$_)
	,CString: ($_=function(v) { return {_hx_index:2,v:v,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="CString",$_.__params__ = ["v"],$_)
	,Kwd: ($_=function(s) { return {_hx_index:3,s:s,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="Kwd",$_.__params__ = ["s"],$_)
	,Ident: ($_=function(s) { return {_hx_index:4,s:s,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="Ident",$_.__params__ = ["s"],$_)
	,Star: {_hx_name:"Star",_hx_index:5,__enum__:"hxsqlparser.Token",toString:$estr}
	,Eof: {_hx_name:"Eof",_hx_index:6,__enum__:"hxsqlparser.Token",toString:$estr}
	,POpen: {_hx_name:"POpen",_hx_index:7,__enum__:"hxsqlparser.Token",toString:$estr}
	,PClose: {_hx_name:"PClose",_hx_index:8,__enum__:"hxsqlparser.Token",toString:$estr}
	,Comma: {_hx_name:"Comma",_hx_index:9,__enum__:"hxsqlparser.Token",toString:$estr}
	,Op: ($_=function(op) { return {_hx_index:10,op:op,__enum__:"hxsqlparser.Token",toString:$estr}; },$_._hx_name="Op",$_.__params__ = ["op"],$_)
};
hxsqlparser_Token.__constructs__ = [hxsqlparser_Token.CInt,hxsqlparser_Token.CFloat,hxsqlparser_Token.CString,hxsqlparser_Token.Kwd,hxsqlparser_Token.Ident,hxsqlparser_Token.Star,hxsqlparser_Token.Eof,hxsqlparser_Token.POpen,hxsqlparser_Token.PClose,hxsqlparser_Token.Comma,hxsqlparser_Token.Op];
var hxsqlparser_TokenBinop = $hxEnums["hxsqlparser.TokenBinop"] = { __ename__:true,__constructs__:null
	,Eq: {_hx_name:"Eq",_hx_index:0,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
	,Lt: {_hx_name:"Lt",_hx_index:1,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
	,Gt: {_hx_name:"Gt",_hx_index:2,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
	,LtEq: {_hx_name:"LtEq",_hx_index:3,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
	,GtEq: {_hx_name:"GtEq",_hx_index:4,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
	,Neq: {_hx_name:"Neq",_hx_index:5,__enum__:"hxsqlparser.TokenBinop",toString:$estr}
};
hxsqlparser_TokenBinop.__constructs__ = [hxsqlparser_TokenBinop.Eq,hxsqlparser_TokenBinop.Lt,hxsqlparser_TokenBinop.Gt,hxsqlparser_TokenBinop.LtEq,hxsqlparser_TokenBinop.GtEq,hxsqlparser_TokenBinop.Neq];
class hxsqlparser_SqlLexer {
	constructor() {
		this.idChar = [];
		let _g = 65;
		while(_g < 91) this.idChar[_g++] = true;
		let _g1 = 97;
		while(_g1 < 123) this.idChar[_g1++] = true;
		let _g2 = 48;
		while(_g2 < 58) this.idChar[_g2++] = true;
		this.idChar[95] = true;
		let _g3 = new haxe_ds_StringMap();
		let _g4 = 0;
		let _g5 = hxsqlparser_SqlLexer.KWDS;
		while(_g4 < _g5.length) _g3.h[_g5[_g4++]] = true;
		this.keywords = _g3;
	}
	lex(q) {
		this.query = q;
		this.pos = 0;
		this.cache = [];
		let result = [];
		while(true) {
			let t = this.token();
			if(t == null) {
				break;
			}
			result.push(t);
		}
		return result;
	}
	token() {
		let t = this.cache.pop();
		if(t != null) {
			return t;
		}
		while(true) {
			if(this.pos >= this.query.length) {
				return null;
			}
			let c = this.query.charCodeAt(this.pos++);
			switch(c) {
			case 9:case 10:case 13:case 32:
				continue;
			case 34:case 39:
				let strStart = this.pos;
				let strChar = c;
				while(true) {
					c = this.query.charCodeAt(this.pos++);
					if(c == strChar) {
						break;
					}
					if(this.pos > this.query.length) {
						throw haxe_Exception.thrown("Unclosed string");
					}
				}
				return hxsqlparser_Token.CString(HxOverrides.substr(this.query,strStart,this.pos - 1 - strStart));
			case 40:
				return hxsqlparser_Token.POpen;
			case 41:
				return hxsqlparser_Token.PClose;
			case 42:
				return hxsqlparser_Token.Star;
			case 44:
				return hxsqlparser_Token.Comma;
			case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
				let n = (c - 48) * 1.0;
				let exp = 0.;
				while(true) {
					c = this.query.charCodeAt(this.pos++);
					exp *= 10;
					switch(c) {
					case 46:
						if(exp > 0) {
							this.invalidChar(c);
						}
						exp = 1.;
						break;
					case 48:case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:
						n = n * 10 + (c - 48);
						break;
					default:
						this.pos--;
						let i = n | 0;
						if(exp > 0) {
							return hxsqlparser_Token.CFloat(n * 10 / exp);
						} else if(i == n) {
							return hxsqlparser_Token.CInt(i);
						} else {
							return hxsqlparser_Token.CFloat(n);
						}
					}
				}
				break;
			case 61:
				return hxsqlparser_Token.Op(hxsqlparser_TokenBinop.Eq);
			case 96:
				let start = this.pos;
				do c = this.query.charCodeAt(this.pos++); while(this.idChar[c]);
				if(c != 96) {
					throw haxe_Exception.thrown("Unclosed `");
				}
				return hxsqlparser_Token.Ident(HxOverrides.substr(this.query,start,this.pos - 1 - start));
			default:
				if(c >= 65 && c <= 90 || c >= 97 && c <= 122) {
					let start = this.pos - 1;
					do c = this.query.charCodeAt(this.pos++); while(this.idChar[c]);
					this.pos--;
					let i = HxOverrides.substr(this.query,start,this.pos - start);
					let iup = i.toUpperCase();
					if(Object.prototype.hasOwnProperty.call(this.keywords.h,iup)) {
						return hxsqlparser_Token.Kwd(iup);
					}
					return hxsqlparser_Token.Ident(i);
				}
				if(c != c) {
					return hxsqlparser_Token.Eof;
				}
				this.invalidChar(c);
			}
		}
	}
	nextChar() {
		return this.query.charCodeAt(this.pos++);
	}
	isIdentChar(c) {
		return this.idChar[c];
	}
	invalidChar(c) {
		throw haxe_Exception.thrown("Unexpected char '" + String.fromCodePoint(c) + "'");
	}
}
hxsqlparser_SqlLexer.__name__ = "hxsqlparser.SqlLexer";
Object.assign(hxsqlparser_SqlLexer.prototype, {
	__class__: hxsqlparser_SqlLexer
});
class hxsqlparser_SqlParser {
	constructor() {
	}
	parse(sql) {
		let lexer = new hxsqlparser_SqlLexer();
		return new hxsqlparser_SqlCommandParse().parse(lexer.lex(sql));
	}
}
hxsqlparser_SqlParser.__name__ = "hxsqlparser.SqlParser";
Object.assign(hxsqlparser_SqlParser.prototype, {
	__class__: hxsqlparser_SqlParser
});
class hxsqlparser_branches_Alter {
	static parse(parser) {
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "TABLE")) {
			throw haxe_Exception.thrown("Expected TABLE, found: " + Std.string(token));
		}
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		let alters = [];
		while(parser.pos < parser.tokens.length) {
			token = parser.nextToken();
			if(token._hx_index == 3) {
				switch(token.s) {
				case "ADD":
					let column = parser.nextToken();
					if(!(column._hx_index == 3 && column.s == "COLUMN")) {
						throw haxe_Exception.thrown("Expected COLUMN after ADD");
					}
					let columnName = parser.nextToken();
					if(columnName._hx_index != 4) {
						throw haxe_Exception.thrown("Expected column name");
					}
					let columnType = parser.nextToken();
					if(columnType._hx_index != 4) {
						throw haxe_Exception.thrown("Expected column type");
					}
					alters.push(hxsqlparser_AlterCommand.AddColumn(parser.extractValue(columnName),parser.parseSqlType(parser.extractValue(columnType))));
					break;
				case "DROP":
					let column1 = parser.nextToken();
					if(!(column1._hx_index == 3 && column1.s == "COLUMN")) {
						throw haxe_Exception.thrown("Expected COLUMN after DROP");
					}
					let columnName1 = parser.nextToken();
					if(columnName1._hx_index != 4) {
						throw haxe_Exception.thrown("Expected column name");
					}
					alters.push(hxsqlparser_AlterCommand.DropColumn(parser.extractValue(columnName1)));
					break;
				case "MODIFY":
					let column2 = parser.nextToken();
					if(!(column2._hx_index == 3 && column2.s == "COLUMN")) {
						throw haxe_Exception.thrown("Expected COLUMN after MODIFY");
					}
					let columnName2 = parser.nextToken();
					if(columnName2._hx_index != 4) {
						throw haxe_Exception.thrown("Expected column name");
					}
					let columnType1 = parser.nextToken();
					if(columnType1._hx_index != 4) {
						throw haxe_Exception.thrown("Expected column type");
					}
					alters.push(hxsqlparser_AlterCommand.ModifyColumn(parser.extractValue(columnName2),parser.parseSqlType(parser.extractValue(columnType1))));
					break;
				case "RENAME":
					let to = parser.nextToken();
					if(!(to._hx_index == 3 && to.s == "TO")) {
						throw haxe_Exception.thrown("Expected TO after RENAME");
					}
					let newName = parser.nextToken();
					if(newName._hx_index != 4) {
						throw haxe_Exception.thrown("Expected new table name");
					}
					alters.push(hxsqlparser_AlterCommand.RenameTo(parser.extractValue(newName)));
					break;
				default:
					throw haxe_Exception.thrown("Unexpected token in ALTER TABLE command: " + Std.string(token));
				}
			} else {
				throw haxe_Exception.thrown("Unexpected token in ALTER TABLE command: " + Std.string(token));
			}
			token = parser.peekToken();
			if(token == null || token == hxsqlparser_Token.Eof || token._hx_index != 3) {
				break;
			}
		}
		return hxsqlparser_SqlCommand.AlterTable(parser.extractValue(table),alters);
	}
}
hxsqlparser_branches_Alter.__name__ = "hxsqlparser.branches.Alter";
class hxsqlparser_branches_Create {
	static parse(parser) {
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "TABLE")) {
			throw haxe_Exception.thrown("Expected TABLE, found: " + Std.string(token));
		}
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		let fields = [];
		if(parser.nextToken() != hxsqlparser_Token.POpen) {
			throw haxe_Exception.thrown("Expected ( after table name");
		}
		while(true) {
			let fieldName = parser.nextToken();
			if(fieldName._hx_index != 4) {
				throw haxe_Exception.thrown("Expected field name");
			}
			let fieldType = parser.nextToken();
			if(fieldType._hx_index != 4) {
				throw haxe_Exception.thrown("Expected field type");
			}
			fields.push({ name : parser.extractValue(fieldName), type : parser.parseSqlType(parser.extractValue(fieldType))});
			token = parser.nextToken();
			if(token == hxsqlparser_Token.PClose) {
				break;
			}
			if(token != hxsqlparser_Token.Comma) {
				throw haxe_Exception.thrown("Expected , or ) in field list");
			}
		}
		return hxsqlparser_SqlCommand.CreateTable(parser.extractValue(table),fields);
	}
}
hxsqlparser_branches_Create.__name__ = "hxsqlparser.branches.Create";
class hxsqlparser_branches_Delete {
	static parse(parser) {
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "FROM")) {
			throw haxe_Exception.thrown("Expected FROM, found: " + Std.string(token));
		}
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		let whereClause = [];
		token = parser.peekToken();
		if(token._hx_index == 3 && token.s == "WHERE") {
			whereClause = hxsqlparser_branches_WhereClause.parse(parser);
		}
		return hxsqlparser_SqlCommand.Delete(parser.extractValue(table),whereClause);
	}
}
hxsqlparser_branches_Delete.__name__ = "hxsqlparser.branches.Delete";
class hxsqlparser_branches_Drop {
	static parse(parser) {
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "TABLE")) {
			throw haxe_Exception.thrown("Expected TABLE, found: " + Std.string(token));
		}
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		return hxsqlparser_SqlCommand.DropTable(parser.extractValue(table));
	}
}
hxsqlparser_branches_Drop.__name__ = "hxsqlparser.branches.Drop";
class hxsqlparser_branches_Insert {
	static parse(parser) {
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "INTO")) {
			throw haxe_Exception.thrown("Expected INTO, found: " + Std.string(token));
		}
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		let fields = [];
		token = parser.peekToken();
		if(token._hx_index == 7) {
			while(token._hx_index != 8) {
				token = parser.nextToken();
				if(token._hx_index == 4) {
					fields.push({ table : "", field : token.s, all : false});
				}
			}
		}
		let insertValue = hxsqlparser_branches_Insert.parseInsertValue(parser);
		return hxsqlparser_SqlCommand.Insert(parser.extractValue(table),fields,insertValue);
	}
	static parseInsertValue(parser) {
		let token = parser.nextToken();
		if(token._hx_index == 3) {
			switch(token.s) {
			case "SELECT":
				return hxsqlparser_InsertValue.Query(hxsqlparser_branches_Select.parse(parser));
			case "VALUES":
				if(parser.nextToken() != hxsqlparser_Token.POpen) {
					throw haxe_Exception.thrown("Expected ( to start INSERT values");
				}
				let fields = [];
				while(true) {
					let field = parser.nextToken();
					switch(field._hx_index) {
					case 0:
						break;
					case 1:
						break;
					case 2:
						break;
					case 4:
						break;
					case 9:
						continue;
					default:
						throw haxe_Exception.thrown("Unexpected token in INSERT values: " + Std.string(field));
					}
					fields.push(parser.getSqlValue(field));
					if(parser.peekToken() == hxsqlparser_Token.PClose) {
						parser.nextToken();
						break;
					}
				}
				return hxsqlparser_InsertValue.Row(fields);
			default:
				throw haxe_Exception.thrown("Expected VALUES or SELECT, found: " + Std.string(token));
			}
		} else {
			throw haxe_Exception.thrown("Expected VALUES or SELECT, found: " + Std.string(token));
		}
	}
}
hxsqlparser_branches_Insert.__name__ = "hxsqlparser.branches.Insert";
class hxsqlparser_branches_Select {
	static parse(parser) {
		let fields = [];
		let token = parser.nextToken();
		if(token == hxsqlparser_Token.Star) {
			fields.push({ table : "", field : "", all : true});
			token = parser.nextToken();
		} else {
			while(!(token._hx_index == 3 && token.s == "FROM")) if(token._hx_index == 4) {
				fields.push({ table : "", field : token.s, all : false});
				token = parser.nextToken();
				if(token == hxsqlparser_Token.Comma) {
					token = parser.nextToken();
				}
			} else {
				throw haxe_Exception.thrown("Unexpected token in SELECT fields: " + Std.string(token));
			}
		}
		if(!(token._hx_index == 3 && token.s == "FROM")) {
			throw haxe_Exception.thrown("Expected FROM, found: " + Std.string(token));
		}
		let fromClause = hxsqlparser_branches_Select.fromClause(parser);
		let whereClause = [];
		token = parser.peekToken();
		if(token != null && (token._hx_index == 3 && token.s == "WHERE")) {
			whereClause = hxsqlparser_branches_WhereClause.parse(parser);
		}
		return hxsqlparser_SqlCommand.Select(fields,fromClause,whereClause);
	}
	static fromClause(parser) {
		let next = parser.nextToken();
		if(next._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name in FROM clause");
		}
		return hxsqlparser_FromClause.Table(parser.extractValue(next));
	}
}
hxsqlparser_branches_Select.__name__ = "hxsqlparser.branches.Select";
class hxsqlparser_branches_Update {
	static parse(parser) {
		let table = parser.nextToken();
		if(table._hx_index != 4) {
			throw haxe_Exception.thrown("Expected table name");
		}
		let token = parser.nextToken();
		if(!(token._hx_index == 3 && token.s == "SET")) {
			throw haxe_Exception.thrown("Expected SET, found: " + Std.string(token));
		}
		let setFields = [];
		while(true) {
			let field = parser.nextToken();
			if(field._hx_index != 4) {
				throw haxe_Exception.thrown("Expected field name in SET clause");
			}
			token = parser.nextToken();
			if(!(token._hx_index == 10 && token.op._hx_index == 0)) {
				throw haxe_Exception.thrown("Expected = in SET clause");
			}
			let value = parser.nextToken();
			if(value._hx_index != 4 && value._hx_index != 2 && value._hx_index != 0 && value._hx_index != 1) {
				throw haxe_Exception.thrown("Expected value in SET clause");
			}
			if(field._hx_index == 4) {
				setFields.push({ field : field.s, value : parser.getSqlValue(value)});
			}
			token = parser.peekToken();
			if(token != hxsqlparser_Token.Comma) {
				break;
			}
			parser.nextToken();
		}
		let whereClause = [];
		token = parser.peekToken();
		if(token._hx_index == 3 && token.s == "WHERE") {
			whereClause = hxsqlparser_branches_WhereClause.parse(parser);
		}
		if(table._hx_index == 4) {
			return hxsqlparser_SqlCommand.Update(table.s,setFields,whereClause);
		} else {
			throw haxe_Exception.thrown("Expected table name");
		}
	}
}
hxsqlparser_branches_Update.__name__ = "hxsqlparser.branches.Update";
class hxsqlparser_branches_WhereClause {
	static parse(parser) {
		parser.nextToken();
		let conditions = [];
		while(true) {
			let field = parser.nextToken();
			if(field._hx_index != 4) {
				throw haxe_Exception.thrown("Expected field name in WHERE clause");
			}
			let binop = parser.nextToken();
			if(binop._hx_index != 10) {
				throw haxe_Exception.thrown("Expected binary operator in WHERE clause");
			}
			let value = parser.nextToken();
			if(value._hx_index != 4 && value._hx_index != 0 && value._hx_index != 1) {
				throw haxe_Exception.thrown("Expected value in WHERE clause");
			}
			conditions.push(hxsqlparser_Condition.Relational(parser.extractValue(field),parser.extractValue(binop),parser.getSqlValue(value)));
			let cont = parser.peekToken();
			if(cont == null || !(cont._hx_index == 3 && cont.s == "AND")) {
				break;
			}
			parser.nextToken();
		}
		return conditions;
	}
}
hxsqlparser_branches_WhereClause.__name__ = "hxsqlparser.branches.WhereClause";
class js_Boot {
	static getClass(o) {
		if(o == null) {
			return null;
		} else if(((o) instanceof Array)) {
			return Array;
		} else {
			let cl = o.__class__;
			if(cl != null) {
				return cl;
			}
			let name = js_Boot.__nativeClassName(o);
			if(name != null) {
				return js_Boot.__resolveNativeClass(name);
			}
			return null;
		}
	}
	static __string_rec(o,s) {
		if(o == null) {
			return "null";
		}
		if(s.length >= 5) {
			return "<...>";
		}
		let t = typeof(o);
		if(t == "function" && (o.__name__ || o.__ename__)) {
			t = "object";
		}
		switch(t) {
		case "function":
			return "<function>";
		case "object":
			if(o.__enum__) {
				let e = $hxEnums[o.__enum__];
				let con = e.__constructs__[o._hx_index];
				let n = con._hx_name;
				if(con.__params__) {
					s = s + "\t";
					return n + "(" + ((function($this) {
						var $r;
						let _g = [];
						{
							let _g1 = 0;
							let _g2 = con.__params__;
							while(true) {
								if(!(_g1 < _g2.length)) {
									break;
								}
								let p = _g2[_g1];
								_g1 = _g1 + 1;
								_g.push(js_Boot.__string_rec(o[p],s));
							}
						}
						$r = _g;
						return $r;
					}(this))).join(",") + ")";
				} else {
					return n;
				}
			}
			if(((o) instanceof Array)) {
				let str = "[";
				s += "\t";
				let _g = 0;
				let _g1 = o.length;
				while(_g < _g1) {
					let i = _g++;
					str += (i > 0 ? "," : "") + js_Boot.__string_rec(o[i],s);
				}
				str += "]";
				return str;
			}
			let tostr;
			try {
				tostr = o.toString;
			} catch( _g ) {
				return "???";
			}
			if(tostr != null && tostr != Object.toString && typeof(tostr) == "function") {
				let s2 = o.toString();
				if(s2 != "[object Object]") {
					return s2;
				}
			}
			let str = "{\n";
			s += "\t";
			let hasp = o.hasOwnProperty != null;
			let k = null;
			for( k in o ) {
			if(hasp && !o.hasOwnProperty(k)) {
				continue;
			}
			if(k == "prototype" || k == "__class__" || k == "__super__" || k == "__interfaces__" || k == "__properties__") {
				continue;
			}
			if(str.length != 2) {
				str += ", \n";
			}
			str += s + k + " : " + js_Boot.__string_rec(o[k],s);
			}
			s = s.substring(1);
			str += "\n" + s + "}";
			return str;
		case "string":
			return o;
		default:
			return String(o);
		}
	}
	static __nativeClassName(o) {
		let name = js_Boot.__toStr.call(o).slice(8,-1);
		if(name == "Object" || name == "Function" || name == "Math" || name == "JSON") {
			return null;
		}
		return name;
	}
	static __resolveNativeClass(name) {
		return $global[name];
	}
}
js_Boot.__name__ = "js.Boot";
class ludi_commons_collections_GridMap {
	constructor() {
		this.yMax = new ludi_commons_math_MaxIntFinder();
		this.xMax = new ludi_commons_math_MaxIntFinder();
		this.data = new haxe_ds_IntMap();
	}
	all() {
		let result = [];
		let eachItemInData = this.data.iterator();
		while(eachItemInData.hasNext()) {
			let eachItemInEachItemInData = eachItemInData.next().iterator();
			while(eachItemInEachItemInData.hasNext()) {
				let eachItemInEachItemInData1 = eachItemInEachItemInData.next();
				if(eachItemInEachItemInData1 != null) {
					result.push(eachItemInEachItemInData1);
				}
			}
		}
		return result;
	}
	change(x1,y1,x2,y2,item) {
		this.add(x1,y1,null);
		this.add(x2,y2,item);
	}
	dimensions() {
		return new ludi_commons_math_IVec2(this.xMax.getMax(),this.yMax.getMax());
	}
	forEach(func) {
		let _g = 0;
		let _g1 = this.xMax.getMax() + 1;
		while(_g < _g1) {
			let x = _g++;
			let _g1 = 0;
			let _g2 = this.yMax.getMax() + 1;
			while(_g1 < _g2) {
				let y = _g1++;
				let check = this.get(x,y);
				if(check != null) {
					func(x,y,check);
				}
			}
		}
	}
	forEachRow(func) {
		let _g = 0;
		let _g1 = this.yMax.getMax() + 1;
		while(_g < _g1) {
			let y = _g++;
			let row = [];
			let _g1 = 0;
			let _g2 = this.xMax.getMax() + 1;
			while(_g1 < _g2) {
				let item = this.get(_g1++,y);
				if(item != null) {
					row.push(item);
				}
			}
			func(y,row);
		}
	}
	forEachCartesian(func) {
		let _g = 0;
		let _g1 = this.xMax.getMax() + 1;
		while(_g < _g1) {
			let x = _g++;
			let _g1 = 0;
			let _g2 = this.yMax.getMax() + 1;
			while(_g1 < _g2) {
				let y = _g1++;
				func(x,y,this.get(x,y));
			}
		}
	}
	add(x,y,item) {
		this.xMax.consume(x);
		this.yMax.consume(y);
		if(this.data.h[x] == null) {
			this.data.h[x] = new haxe_ds_IntMap();
		}
		this.data.h[x].h[y] = item;
	}
	remove(x,y) {
		if(this.data.h[x] != null) {
			this.data.h[x].h[y] = null;
		}
	}
	has(x,y) {
		if(this.data.h[x] == null) {
			return false;
		}
		if(this.data.h[x].h[y] == null) {
			return false;
		}
		return true;
	}
	flatten() {
		let result = [];
		this.forEach(function(x,y,item) {
			result.push(item);
		});
		return result;
	}
	get(x,y) {
		if(this.data.h[x] == null) {
			this.data.h[x] = new haxe_ds_IntMap();
		}
		return this.data.h[x].h[y];
	}
	serialize() {
		let flatData = [];
		this.forEach(function(x,y,item) {
			flatData.push({ x : x, y : y, item : item});
		});
		return JSON.stringify({ data : flatData, xMax : this.xMax.getMax(), yMax : this.yMax.getMax()},null," ");
	}
	translate(delta) {
		let translatedGrid = new ludi_commons_collections_GridMap();
		this.forEach(function(x,y,item) {
			translatedGrid.add(x + delta.x,y + delta.y,item);
		});
		return translatedGrid;
	}
	normalize() {
		let minX = 2147483647;
		let minY = 2147483647;
		this.forEach(function(x,y,item) {
			if(x < minX) {
				minX = x;
			}
			if(y < minY) {
				minY = y;
			}
		});
		let topLeftItem = null;
		this.forEach(function(x,y,item) {
			if(x == minX && y <= minY || y == minY && x <= minX) {
				topLeftItem = item;
				minY = y;
			}
		});
		return this.translate(new ludi_commons_math_IVec2(-minX,-minY));
	}
	clone() {
		let newGridMap = new ludi_commons_collections_GridMap();
		let x = this.data.keys();
		while(x.hasNext()) {
			let x1 = x.next();
			let y = this.data.h[x1].keys();
			while(y.hasNext()) {
				let y1 = y.next();
				newGridMap.add(x1,y1,this.data.h[x1].h[y1]);
			}
		}
		return newGridMap;
	}
	outerJoin(arg) {
		let _gthis = this;
		arg.forEach(function(x,y,item) {
			if(!_gthis.has(x,y)) {
				_gthis.add(x,y,item);
			}
		});
	}
	clear() {
		this.data = new haxe_ds_IntMap();
		this.xMax = new ludi_commons_math_MaxIntFinder();
		this.yMax = new ludi_commons_math_MaxIntFinder();
	}
	truncateTo(xMaxLimit,yMaxLimit) {
		let positionsToRemove = [];
		this.forEach(function(x,y,item) {
			if(x >= xMaxLimit || y >= yMaxLimit) {
				positionsToRemove.push({ x : x, y : y});
			}
		});
		let _g = 0;
		while(_g < positionsToRemove.length) {
			let pos = positionsToRemove[_g];
			++_g;
			this.remove(pos.x,pos.y);
		}
		let newXMax = new ludi_commons_math_MaxIntFinder();
		let newYMax = new ludi_commons_math_MaxIntFinder();
		this.forEach(function(x,y,item) {
			newXMax.consume(x);
			newYMax.consume(y);
		});
		this.xMax = newXMax;
		this.yMax = newYMax;
	}
	static deserialize(json) {
		let obj = JSON.parse(json);
		let grid = new ludi_commons_collections_GridMap();
		grid.xMax = new ludi_commons_math_MaxIntFinder();
		grid.xMax.consume(obj.xMax);
		grid.yMax = new ludi_commons_math_MaxIntFinder();
		grid.yMax.consume(obj.yMax);
		let _g = 0;
		let _g1 = obj.data;
		while(_g < _g1.length) {
			let item = _g1[_g];
			++_g;
			grid.add(item.x,item.y,item.item);
		}
		return grid;
	}
}
ludi_commons_collections_GridMap.__name__ = "ludi.commons.collections.GridMap";
Object.assign(ludi_commons_collections_GridMap.prototype, {
	__class__: ludi_commons_collections_GridMap
});
class ludi_commons_extensions_All {
}
ludi_commons_extensions_All.__name__ = "ludi.commons.extensions.All";
class ludi_commons_extensions_Extensions_$Collections {
	static mapLength(map) {
		let i = 0;
		let _g = map.keyValueIterator();
		while(_g.hasNext()) {
			_g.next();
			++i;
		}
		return i;
	}
	static toGrid(arr,mapper) {
		let grid = new ludi_commons_collections_GridMap();
		let _g = 0;
		while(_g < arr.length) {
			let item = arr[_g];
			++_g;
			let pos = mapper(item);
			grid.add(pos.x,pos.y,item);
		}
		return grid;
	}
	static toKeyValueArray(map) {
		let arr = [];
		let key = map.keys();
		while(key.hasNext()) {
			let key1 = key.next();
			arr.push({ key : key1, value : map.get(key1)});
		}
		return arr;
	}
	static cartesianProduct(array1,array2) {
		let result = [];
		let _g = 0;
		while(_g < array1.length) {
			let elem1 = array1[_g++];
			let _g1 = 0;
			while(_g1 < array2.length) result.push({ a : elem1, b : array2[_g1++]});
		}
		return result;
	}
	static firstOrNull(arr) {
		if(arr.length > 0) {
			return arr[0];
		} else {
			return null;
		}
	}
	static findByUUID(arr,uuid) {
		let _g = 0;
		while(_g < arr.length) {
			let eachArr = arr[_g];
			++_g;
			if(eachArr.uuid == uuid) {
				return eachArr;
			}
		}
		return null;
	}
	static getsert(map,key,def) {
		if(Object.prototype.hasOwnProperty.call(map.h,key)) {
			return map.h[key];
		}
		map.h[key] = def;
		return def;
	}
	static getsertLazy(map,key,def) {
		if(Object.prototype.hasOwnProperty.call(map.h,key)) {
			return map.h[key];
		}
		let d = def();
		map.h[key] = d;
		return d;
	}
	static upsert(arr,filter,defaultItem) {
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			if(filter(arr[i])) {
				arr[i] = defaultItem;
			}
		}
		arr.push(defaultItem);
	}
	static jsonified(arr) {
		let result = new Array(arr.length);
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			result[i] = JSON.stringify(arr[i]);
		}
		return result;
	}
	static surgery(arr,idxes) {
		let result = [];
		let _g = 0;
		while(_g < idxes.length) result.push(arr[idxes[_g++]]);
		return result;
	}
	static range(arr,idxStart,idxEnd) {
		let result = [];
		let _g = idxStart;
		let _g1 = idxEnd + 1;
		while(_g < _g1) result.push(arr[_g++]);
		return result;
	}
	static find(arr,filter) {
		let _g = [];
		let _g1 = 0;
		while(_g1 < arr.length) {
			let v = arr[_g1];
			++_g1;
			if(filter(v)) {
				_g.push(v);
			}
		}
		if(_g.length > 0) {
			return _g[0];
		}
		return null;
	}
	static reduce(arr,callback,initialValue) {
		let accumulator = initialValue;
		let _g = 0;
		while(_g < arr.length) accumulator = callback(accumulator,arr[_g++]);
		return accumulator;
	}
	static all(arr,filter) {
		let _g = 0;
		while(_g < arr.length) if(!filter(arr[_g++])) {
			return false;
		}
		return true;
	}
	static filterValues(map,filter) {
		let result = [];
		let _g = map.keyValueIterator();
		while(_g.hasNext()) {
			let _g1 = _g.next();
			let value = _g1.value;
			if(filter(_g1.key,value)) {
				result.push(value);
			}
		}
		return result;
	}
	static some(arr,filter) {
		let _g = 0;
		while(_g < arr.length) if(filter(arr[_g++])) {
			return true;
		}
		return false;
	}
	static every(arr,filter) {
		let _g = 0;
		while(_g < arr.length) if(!filter(arr[_g++])) {
			return false;
		}
		return true;
	}
	static take(arr,amount) {
		let result = [];
		let _g = 0;
		let _g1 = arr.length;
		while(_g < _g1) {
			let i = _g++;
			if(i < amount) {
				result.push(arr[i]);
			} else {
				break;
			}
		}
		return result;
	}
	static maxInt(arr,compute) {
		let currentMaxValue = -Infinity;
		let currentMaxItem = null;
		let _g = 0;
		while(_g < arr.length) {
			let eachItem = arr[_g];
			++_g;
			let val = compute(eachItem);
			if(val > currentMaxValue) {
				currentMaxValue = val;
				currentMaxItem = eachItem;
			}
		}
		return currentMaxItem;
	}
	static computeInt(arr,compute) {
		let currentValue = 0;
		let _g = 0;
		while(_g < arr.length) currentValue = compute(arr[_g++],currentValue);
		return currentValue;
	}
	static pushAll(arr,toAdd) {
		let _g = 0;
		while(_g < toAdd.length) arr.push(toAdd[_g++]);
		return arr;
	}
	static random(arr) {
		return arr[Math.floor(Math.random() * arr.length)];
	}
	static subtract(arr1,arr2) {
		let result = [];
		let _g = 0;
		while(_g < arr1.length) {
			let item = arr1[_g];
			++_g;
			if(!arr2.includes(item)) {
				result.push(item);
			}
		}
		return result;
	}
	static removeWhere(arr,func) {
		let itemsToRemove = [];
		let _g = 0;
		while(_g < arr.length) {
			let eachItemInArr = arr[_g];
			++_g;
			if(func(eachItemInArr)) {
				itemsToRemove.push(eachItemInArr);
			}
		}
		let _g1 = 0;
		while(_g1 < itemsToRemove.length) HxOverrides.remove(arr,itemsToRemove[_g1++]);
	}
	static verticalCut(arr,idx) {
		let result = [];
		let _g = 0;
		while(_g < arr.length) {
			let subArr = arr[_g];
			++_g;
			if(idx >= 0 && idx < subArr.length) {
				result.push(subArr[idx]);
			} else {
				result.push(null);
			}
		}
		return result;
	}
}
ludi_commons_extensions_Extensions_$Collections.__name__ = "ludi.commons.extensions.Extensions_Collections";
class ludi_commons_extensions_Extensions_$Enum {
	static convert(e,v) {
		console.log("ludi/commons/extensions/Extensions_Enum.hx:8:","converting: " + Std.string(v) + "  " + v._hx_index + "  " + Std.string(Type.enumParameters(v)));
		return Type.createEnumIndex(e,v._hx_index,Type.enumParameters(v));
	}
}
ludi_commons_extensions_Extensions_$Enum.__name__ = "ludi.commons.extensions.Extensions_Enum";
class ludi_commons_extensions_Extensions_$Math {
	static sign(math,val) {
		if(val < 0) {
			return -1;
		}
		if(val > 0) {
			return 1;
		}
		return 0;
	}
	static maxAll(math,vals) {
		let max = -2147483648;
		let _g = 0;
		while(_g < vals.length) max = Math.max(max,vals[_g++]) | 0;
		return max;
	}
	static sum(arr) {
		let val = 0;
		let _g = 0;
		while(_g < arr.length) val += arr[_g++];
		return val;
	}
	static minInt(math,a,b) {
		if(a < b || isNaN(a)) {
			return a;
		} else {
			return b;
		}
	}
	static maxInt(math,a,b) {
		if(a > b) {
			return a;
		} else {
			return b;
		}
	}
	static bound(math,v,min,max) {
		if(v < min) {
			return min;
		}
		if(v > max) {
			return max;
		}
		return v;
	}
	static boundFloat(math,v,min,max) {
		if(v < min) {
			return min;
		}
		if(v > max) {
			return max;
		}
		return v;
	}
}
ludi_commons_extensions_Extensions_$Math.__name__ = "ludi.commons.extensions.Extensions_Math";
class ludi_commons_extensions_Extensions_$Model {
	static invert(dir) {
		switch(dir._hx_index) {
		case 0:
			return ludi_commons_model_Direction.Down;
		case 1:
			return ludi_commons_model_Direction.Left;
		case 2:
			return ludi_commons_model_Direction.Up;
		case 3:
			return ludi_commons_model_Direction.Right;
		}
	}
}
ludi_commons_extensions_Extensions_$Model.__name__ = "ludi.commons.extensions.Extensions_Model";
class ludi_commons_math_IVec2 {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
	scale(scaler) {
		let copy = new ludi_commons_math_Vec2(this.x,this.y);
		copy.x *= scaler;
		copy.y *= scaler;
		return copy;
	}
	clone() {
		return new ludi_commons_math_IVec2(this.x,this.y);
	}
	add(vec2) {
		return new ludi_commons_math_IVec2(this.x + vec2.x,this.y + vec2.y);
	}
	subtract(vec2) {
		return new ludi_commons_math_IVec2(this.x - vec2.x,this.y - vec2.y);
	}
	magnitude() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	normalize() {
		if(this.magnitude() != 0) {
			return this.scale(1 / this.magnitude());
		} else {
			return new ludi_commons_math_Vec2(0,0);
		}
	}
	distance(otherVec) {
		return this.subtract(otherVec).magnitude();
	}
	intDistance(otherVec) {
		return (Math.abs(this.x - otherVec.x) | 0) + (Math.abs(this.y - otherVec.y) | 0);
	}
	equals(otherVec) {
		if(this.x == otherVec.x) {
			return this.y == otherVec.y;
		} else {
			return false;
		}
	}
	toString() {
		return JSON.stringify(this);
	}
	static fromString(str) {
		let v = JSON.parse(str);
		return new ludi_commons_math_IVec2(v.x,v.y);
	}
}
ludi_commons_math_IVec2.__name__ = "ludi.commons.math.IVec2";
Object.assign(ludi_commons_math_IVec2.prototype, {
	__class__: ludi_commons_math_IVec2
});
class ludi_commons_math_MathTools {
	cartesian(vals) {
		if(vals.length == 0) {
			return [[]];
		} else {
			let result = [];
			let allCasesFromRest = this.cartesian(vals.slice(1));
			let _g = 0;
			let _g1 = vals[0].length;
			while(_g < _g1) {
				let i = _g++;
				let _g1 = 0;
				let _g2 = allCasesFromRest.length;
				while(_g1 < _g2) {
					let singleList = allCasesFromRest[_g1++].slice();
					singleList.splice(0,0,vals[0][i]);
					result.push(singleList);
				}
			}
			return result;
		}
	}
	static minAllInt(values,def) {
		if(def == null) {
			def = 2147483647;
		}
		if(values.length == 0) {
			return def;
		}
		let minValue = values[0];
		let _g = 0;
		while(_g < values.length) {
			let i = values[_g];
			++_g;
			if(i < minValue) {
				minValue = i;
			}
		}
		return minValue;
	}
	static maxAllInt(values,def) {
		if(def == null) {
			def = -2147483648;
		}
		if(values.length == 0) {
			return def;
		}
		let maxValue = values[0];
		let _g = 0;
		while(_g < values.length) {
			let i = values[_g];
			++_g;
			if(i > maxValue) {
				maxValue = i;
			}
		}
		return maxValue;
	}
	static cartesianProductExclusive(x,y) {
		let result = [];
		let _g = 0;
		while(_g < x) {
			let i = _g++;
			let _g1 = 0;
			while(_g1 < y) result.push(new ludi_commons_math_IVec2(i,_g1++));
		}
		return result;
	}
}
ludi_commons_math_MathTools.__name__ = "ludi.commons.math.MathTools";
Object.assign(ludi_commons_math_MathTools.prototype, {
	__class__: ludi_commons_math_MathTools
});
class ludi_commons_math_MaxIntFinder {
	constructor() {
		this.max = -2147483648;
	}
	consume(i) {
		if(i > this.max) {
			this.max = i;
		}
	}
	getMax() {
		return this.max;
	}
}
ludi_commons_math_MaxIntFinder.__name__ = "ludi.commons.math.MaxIntFinder";
Object.assign(ludi_commons_math_MaxIntFinder.prototype, {
	__class__: ludi_commons_math_MaxIntFinder
});
class ludi_commons_math_Vec2 {
	constructor(x,y) {
		this.x = x;
		this.y = y;
	}
	scale(scaler) {
		let copy = this.clone();
		copy.x *= scaler;
		copy.y *= scaler;
		return copy;
	}
	clone() {
		return new ludi_commons_math_Vec2(this.x,this.y);
	}
	add(vec2) {
		return new ludi_commons_math_Vec2(this.x + vec2.x,this.y + vec2.y);
	}
	subtract(vec2) {
		return new ludi_commons_math_Vec2(this.x - vec2.x,this.y - vec2.y);
	}
	magnitude() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	}
	normalize() {
		if(this.magnitude() != 0) {
			return this.scale(1 / this.magnitude());
		} else {
			return new ludi_commons_math_Vec2(0,0);
		}
	}
	distance(otherVec) {
		return this.subtract(otherVec).magnitude();
	}
	equals(otherVec) {
		if(this.x == otherVec.x) {
			return this.y == otherVec.y;
		} else {
			return false;
		}
	}
	toString() {
		return "[x: " + this.x + ", y: " + this.y + "]";
	}
}
ludi_commons_math_Vec2.__name__ = "ludi.commons.math.Vec2";
Object.assign(ludi_commons_math_Vec2.prototype, {
	__class__: ludi_commons_math_Vec2
});
var ludi_commons_model_Direction = $hxEnums["ludi.commons.model.Direction"] = { __ename__:true,__constructs__:null
	,Up: {_hx_name:"Up",_hx_index:0,__enum__:"ludi.commons.model.Direction",toString:$estr}
	,Right: {_hx_name:"Right",_hx_index:1,__enum__:"ludi.commons.model.Direction",toString:$estr}
	,Down: {_hx_name:"Down",_hx_index:2,__enum__:"ludi.commons.model.Direction",toString:$estr}
	,Left: {_hx_name:"Left",_hx_index:3,__enum__:"ludi.commons.model.Direction",toString:$estr}
};
ludi_commons_model_Direction.__constructs__ = [ludi_commons_model_Direction.Up,ludi_commons_model_Direction.Right,ludi_commons_model_Direction.Down,ludi_commons_model_Direction.Left];
class test_TestSQL {
	static main() {
		let s = new util_query_SqlEngine(new cdb_Database());
		s.run("create table test (a int, b int)");
		s.run("insert into test values (1, 2)");
		console.log("test/TestSQL.hx:14:",JSON.stringify(s.run("select * from test")));
		s.run("create table test2 (a int, b int)");
		s.run("insert into test2 (a, b) values (3, 4)");
		s.run("insert into test2 (a, b) values (5, 6)");
		s.run("insert into test2 (a, b) values (3, 4)");
		s.run("insert into test2 (a, b) values (5, 6)");
		console.log("test/TestSQL.hx:21:",JSON.stringify(s.run("select * from test2")));
		s.run("insert into test (a, b) select * from test2");
		s.run("insert into test (a, b) select * from test");
		console.log("test/TestSQL.hx:25:",JSON.stringify(s.run("select * from test")));
	}
}
test_TestSQL.__name__ = "test.TestSQL";
class util_query_Querier {
	constructor(database) {
		this.database = database;
		this.data = database.data;
	}
	select(fields,fromTable,whereClause) {
		let _this = this.data.sheets;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.name == fromTable) {
				_g.push(v);
			}
		}
		let result = new Array(_g.length);
		let _g2 = 0;
		let _g3 = _g.length;
		while(_g2 < _g3) {
			let i = _g2++;
			let _this = _g[i].lines;
			let _g1 = [];
			let _g3 = 0;
			while(_g3 < _this.length) {
				let v = _this[_g3];
				++_g3;
				if(whereClause(v)) {
					_g1.push(v);
				}
			}
			result[i] = _g1;
		}
		let result1 = new Array(result.length);
		let _g4 = 0;
		let _g5 = result.length;
		while(_g4 < _g5) {
			let i = _g4++;
			let line = result[i];
			console.log("src/util/query/Querier.hx:26:","each select line: " + JSON.stringify(line));
			let result2 = { };
			let returnAll = false;
			let _g = 0;
			while(_g < fields.length) {
				let eachField = fields[_g];
				++_g;
				if(eachField.all) {
					returnAll = true;
					break;
				}
				result2[eachField.field] = Reflect.field(line,eachField.field);
			}
			if(returnAll) {
				let _g = 0;
				let _g1 = Reflect.fields(line);
				while(_g < _g1.length) {
					let field = _g1[_g];
					++_g;
					result2[field] = Reflect.field(line,field);
				}
			}
			result1[i] = result2;
		}
		let _g6 = [];
		let _g7 = 0;
		let _g8 = Reflect.fields(result1[0]);
		while(_g7 < _g8.length) _g6.push(Reflect.field(result1[0],_g8[_g7++]));
		return _g6;
	}
	delete(fromTable,whereClause) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == fromTable;
		});
		if(table != null) {
			let _this = table.lines;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(!whereClause(v)) {
					_g.push(v);
				}
			}
			table.lines = _g;
		}
		this.database.syncbackData();
	}
	update(fromTable,fields,whereClause) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == fromTable;
		});
		if(table != null) {
			let _g = 0;
			let _g1 = table.lines;
			while(_g < _g1.length) {
				let line = _g1[_g];
				++_g;
				if(whereClause(line)) {
					let _g = 0;
					let _g1 = Reflect.fields(fields);
					while(_g < _g1.length) {
						let field = _g1[_g];
						++_g;
						line[field] = Reflect.field(fields,field);
					}
				}
			}
		}
		this.database.syncbackData();
	}
	insert(fromTable,row,writeback) {
		if(writeback == null) {
			writeback = true;
		}
		let objArg = util_query_Querier.parseObjectClause(row);
		switch(objArg._hx_index) {
		case 0:
			break;
		case 1:
			let _g = objArg.arr;
			let _g1 = 0;
			while(_g1 < _g.length) this.insert(fromTable,_g[_g1++],false);
			break;
		case 2:
			let _g2 = objArg.val;
			let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
				return sheet.name == fromTable;
			});
			if(table != null) {
				let o = this.database.getSheet(table.name).newLine();
				let _g = 0;
				let _g1 = Reflect.fields(_g2);
				while(_g < _g1.length) {
					let field = _g1[_g];
					++_g;
					o[field] = Reflect.field(_g2,field);
				}
			}
			break;
		}
		if(writeback) {
			this.database.syncbackData();
		}
	}
	count(fromTable,whereClause) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == fromTable;
		});
		if(table != null) {
			let _this = table.lines;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(whereClause(v)) {
					_g.push(v);
				}
			}
			return _g.length;
		}
		return 0;
	}
	createTable(tableName,fields) {
		this.data.sheets.push({ sheetType : "Data Sheet", name : tableName, columns : fields, lines : [], props : { }, separators : []});
		this.database.syncbackData();
	}
	dropTable(tableName) {
		let _this = this.data.sheets;
		let _g = [];
		let _g1 = 0;
		while(_g1 < _this.length) {
			let v = _this[_g1];
			++_g1;
			if(v.name != tableName) {
				_g.push(v);
			}
		}
		this.data.sheets = _g;
	}
	addColumn(tableName,columnName,columnType) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == tableName;
		});
		if(table != null) {
			table.columns.push({ name : columnName, type : columnType, typeStr : cdb_Parser.saveType(columnType)});
		}
	}
	dropColumn(tableName,columnName) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == tableName;
		});
		if(table != null) {
			let _this = table.columns;
			let _g = [];
			let _g1 = 0;
			while(_g1 < _this.length) {
				let v = _this[_g1];
				++_g1;
				if(v.name != columnName) {
					_g.push(v);
				}
			}
			table.columns = _g;
		}
	}
	getColumns(tableName) {
		let table = ludi_commons_extensions_Extensions_$Collections.find(this.data.sheets,function(sheet) {
			return sheet.name == tableName;
		});
		if(table != null) {
			return table.columns;
		}
		return [];
	}
	static parseObjectClause(arg) {
		if(arg == null) {
			return util_query_ObjectClauseType.None;
		} else if(((arg) instanceof Array)) {
			if(arg.length == 0) {
				return util_query_ObjectClauseType.None;
			}
			return util_query_ObjectClauseType.Multiple(arg);
		} else {
			return util_query_ObjectClauseType.Single(arg);
		}
	}
}
util_query_Querier.__name__ = "util.query.Querier";
Object.assign(util_query_Querier.prototype, {
	__class__: util_query_Querier
});
var util_query_ObjectClauseType = $hxEnums["util.query.ObjectClauseType"] = { __ename__:true,__constructs__:null
	,None: {_hx_name:"None",_hx_index:0,__enum__:"util.query.ObjectClauseType",toString:$estr}
	,Multiple: ($_=function(arr) { return {_hx_index:1,arr:arr,__enum__:"util.query.ObjectClauseType",toString:$estr}; },$_._hx_name="Multiple",$_.__params__ = ["arr"],$_)
	,Single: ($_=function(val) { return {_hx_index:2,val:val,__enum__:"util.query.ObjectClauseType",toString:$estr}; },$_._hx_name="Single",$_.__params__ = ["val"],$_)
};
util_query_ObjectClauseType.__constructs__ = [util_query_ObjectClauseType.None,util_query_ObjectClauseType.Multiple,util_query_ObjectClauseType.Single];
class util_query_SqlEngine {
	constructor(database) {
		this.querier = new util_query_Querier(database);
	}
	run(q) {
		let result = [];
		let _g = 0;
		let _g1 = new hxsqlparser_SqlParser().parse(q);
		while(_g < _g1.length) result.push(this.evaluateQuery(_g1[_g++]));
		return result;
	}
	extractTableName(fromClause) {
		if(fromClause._hx_index == 0) {
			return fromClause.table;
		} else {
			return "";
		}
	}
	createWhereFunction(whereClause) {
		let _gthis = this;
		return function(line) {
			let _g = 0;
			while(_g < whereClause.length) if(!_gthis.evaluateCondition(line,whereClause[_g++])) {
				return false;
			}
			return true;
		};
	}
	evaluateQuery(command) {
		console.log("src/util/query/SqlEngine.hx:54:","evaluateQuery: " + Std.string(command));
		switch(command._hx_index) {
		case 0:
			let fromTable = this.extractTableName(command.fromClause);
			let whereFunction = this.createWhereFunction(command.whereClause);
			return this.querier.select(command.fields,fromTable,whereFunction);
		case 1:
			let _g = command.table;
			let _g1 = command.setFields;
			let _g2 = command.whereClause;
			let updateFields = { };
			let _g3 = 0;
			while(_g3 < _g1.length) {
				let setField = _g1[_g3];
				++_g3;
				updateFields[setField.field] = setField.value;
			}
			let whereFunction1 = this.createWhereFunction(_g2);
			this.querier.update(_g,updateFields,whereFunction1);
			break;
		case 2:
			let _g4 = command.table;
			let _g5 = command.fieldNames;
			let _g6 = command.insertValue;
			let fieldNames = _g5;
			if(_g5 == null || _g5.length == 0) {
				fieldNames = [];
				let columns = this.querier.getColumns(_g4);
				let _g = 0;
				while(_g < columns.length) fieldNames.push({ field : columns[_g++].name});
			}
			let insertRow = this.mapInsertValue(fieldNames,_g6);
			this.querier.insert(_g4,insertRow);
			break;
		case 3:
			let whereFunction2 = this.createWhereFunction(command.whereClause);
			this.querier.delete(command.table,whereFunction2);
			break;
		case 4:
			let _g7 = command.table;
			let _g8 = command.fields;
			let fieldMap = [];
			let _g9 = 0;
			while(_g9 < _g8.length) {
				let field = _g8[_g9];
				++_g9;
				let columnType = this.convertType(field.type);
				fieldMap.push({ name : field.name, type : columnType, typeStr : cdb_Parser.saveType(columnType)});
			}
			this.querier.createTable(_g7,fieldMap);
			break;
		case 5:
			let _g10 = command.table;
			let _g11 = command.alters;
			let _g12 = 0;
			while(_g12 < _g11.length) {
				let alter = _g11[_g12];
				++_g12;
				switch(alter._hx_index) {
				case 0:
					break;
				case 1:
					this.querier.addColumn(_g10,alter.name,this.convertType(alter.type));
					break;
				case 2:
					this.querier.dropColumn(_g10,alter.name);
					break;
				case 3:
					break;
				case 4:
					break;
				}
			}
			break;
		case 6:
			this.querier.dropTable(command.table);
			break;
		}
		return null;
	}
	convertType(value) {
		switch(value._hx_index) {
		case 0:
			return cdb_ColumnType.TInt;
		case 1:
			return cdb_ColumnType.TString;
		case 2:
			return cdb_ColumnType.TString;
		case 3:
			return cdb_ColumnType.TBool;
		case 4:
			return cdb_ColumnType.TFloat;
		case 5:
			return cdb_ColumnType.TDynamic;
		case 6:
			return cdb_ColumnType.TDynamic;
		}
	}
	evaluateCondition(line,condition) {
		switch(condition._hx_index) {
		case 0:
			let _g = condition.binop;
			let _g1 = condition.value;
			let lineValue = Reflect.field(line,condition.field);
			let value;
			switch(_g1._hx_index) {
			case 0:
				value = _g1.value;
				break;
			case 1:
				value = this.evaluateQuery(_g1.command);
				break;
			}
			switch(_g._hx_index) {
			case 0:
				return lineValue == value;
			case 1:
				return lineValue != value;
			case 2:
				return lineValue > value;
			case 3:
				return lineValue >= value;
			case 4:
				return lineValue < value;
			case 5:
				return lineValue <= value;
			case 6:
				return lineValue.startsWith(value);
			case 7:
				return !lineValue.startsWith(value);
			case 8:
				return value.indexOf(lineValue) != -1;
			case 9:
				return value.indexOf(lineValue) == -1;
			}
			break;
		case 1:
			return Reflect.field(line,condition.field) == null;
		case 2:
			return Reflect.field(line,condition.field) != null;
		case 3:
			if(this.evaluateCondition(line,condition.left)) {
				return this.evaluateCondition(line,condition.right);
			} else {
				return false;
			}
			break;
		case 4:
			if(!this.evaluateCondition(line,condition.left)) {
				return this.evaluateCondition(line,condition.right);
			} else {
				return true;
			}
			break;
		}
	}
	getValue(value) {
		switch(value._hx_index) {
		case 0:
			return value.value;
		case 1:
			return this.evaluateQuery(value.command);
		}
	}
	mapInsertValue(fieldNames,insertValue) {
		switch(insertValue._hx_index) {
		case 0:
			let _g = insertValue.fields;
			let row = { };
			let _g1 = 0;
			let _g2 = _g.length;
			while(_g1 < _g2) {
				let i = _g1++;
				row[fieldNames[i].field] = this.getValue(_g[i]);
			}
			return row;
		case 1:
			let _g3 = insertValue.rows;
			let result = new Array(_g3.length);
			let _g4 = 0;
			let _g5 = _g3.length;
			while(_g4 < _g5) {
				let i = _g4++;
				result[i] = this.mapInsertValue(fieldNames,_g3[i]);
			}
			return result;
		case 2:
			let result1 = this.evaluateQuery(insertValue.command);
			if(result1 != null) {
				console.log("src/util/query/SqlEngine.hx:192:","internal query result: " + JSON.stringify(result1));
				let arrayedResults = [];
				let _g = 0;
				while(_g < result1.length) {
					let eachEntry = result1[_g];
					++_g;
					let fields = [];
					let _g1 = 0;
					let _g2 = Reflect.fields(eachEntry);
					while(_g1 < _g2.length) fields.push(hxsqlparser_SqlValue.Value(hxsqlparser_SqlType.UNKNOWN,Reflect.field(eachEntry,_g2[_g1++])));
					arrayedResults.push(hxsqlparser_InsertValue.Row(fields));
				}
				return this.mapInsertValue(fieldNames,hxsqlparser_InsertValue.Multiple(arrayedResults));
			}
			break;
		}
		return { };
	}
}
util_query_SqlEngine.__name__ = "util.query.SqlEngine";
Object.assign(util_query_SqlEngine.prototype, {
	__class__: util_query_SqlEngine
});
function $getIterator(o) { if( o instanceof Array ) return new haxe_iterators_ArrayIterator(o); else return o.iterator(); }
function $bind(o,m) { if( m == null ) return null; if( m.__id__ == null ) m.__id__ = $global.$haxeUID++; var f; if( o.hx__closures__ == null ) o.hx__closures__ = {}; else f = o.hx__closures__[m.__id__]; if( f == null ) { f = m.bind(o); o.hx__closures__[m.__id__] = f; } return f; }
$global.$haxeUID |= 0;
if(typeof(performance) != "undefined" ? typeof(performance.now) == "function" : false) {
	HxOverrides.now = performance.now.bind(performance);
}
if( String.fromCodePoint == null ) String.fromCodePoint = function(c) { return c < 0x10000 ? String.fromCharCode(c) : String.fromCharCode((c>>10)+0xD7C0)+String.fromCharCode((c&0x3FF)+0xDC00); }
{
	Object.defineProperty(String.prototype,"__class__",{ value : String, enumerable : false, writable : true});
	String.__name__ = "String";
	Array.__name__ = "Array";
	Date.prototype.__class__ = Date;
	Date.__name__ = "Date";
}
js_Boot.__toStr = ({ }).toString;
cdb_TileMode.Tile = "tile";
cdb_TileMode.Ground = "ground";
cdb_TileMode.Border = "border";
cdb_TileMode.Object = "object";
cdb_TileMode.Group = "group";
cdb_Sheet._UID = 0;
cdb_SheetTypes.DATA_TABLE = "Data Table";
cdb_SheetTypes.LEVELS = "Levels";
haxe_crypto_Base64.CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
haxe_crypto_Base64.BYTES = haxe_io_Bytes.ofString(haxe_crypto_Base64.CHARS);
hxsqlparser_SqlLexer.KWDS = ["ALTER","SELECT","UPDATE","INSERT","INTO","WHERE","CREATE","FROM","TABLE","NOT","NULL","ADD","ON","DELETE","SET","DROP","VALUES","COLUMN","RENAME","TO"];
ludi_commons_math_MathTools.INT_MIN = -2147483648;
ludi_commons_math_MathTools.INT_MAX = 2147483647;
test_TestSQL.main();
})(typeof window != "undefined" ? window : typeof global != "undefined" ? global : typeof self != "undefined" ? self : this);
